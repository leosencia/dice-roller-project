<!DOCTYPE html>
<html>

<head>
    <title>Dice Roller</title>
    <style>
        body {
            margin: 0;
            padding: 0;
            overflow: hidden;
        }

        canvas {
            width: 100vw;
            height: 100vh;
            display: block;
        }

        .buttons {
            position: absolute;
            top: 10px;
            left: 50%;
            transform: translateX(-50%);
            z-index: 1;
            width: max-content;
            height: max-content;
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: 5px;
        }

        .h1 {
            color: white;
        }

        .diceBtn {
            width: 70px;
        }

        #rollDiceBtn{
            width: 100%;
        }
    </style>
    <!--Vertex Shader-->
    <script type="x-shader/x-vertex" id="vshader">
            attribute vec4 aPosition;
            attribute vec2 aTexCoord;
            
            uniform mat4 uModelMatrix;
            uniform mat4 uViewMatrix;
            uniform mat4 uProjectionMatrix;
            
            varying vec2 vTexCoord;

            void main() {
                gl_Position = uProjectionMatrix * uViewMatrix * uModelMatrix * aPosition;
                vTexCoord = aTexCoord;
            }
        </script>

    <!--Fragment Shader-->
    <script type="x-shader/x-fragment" id="fshader">
            precision mediump float;

            uniform vec4 u_color;
            varying vec2 vTexCoord;
            uniform sampler2D uSampler;

            uniform bool uUseTexture;

            void main(void) {
                if (uUseTexture) {
                    gl_FragColor = texture2D(uSampler, vTexCoord);
                } else {
                    gl_FragColor = u_color;
                }
            }
        </script>

    <!--Import external javascript file-->
    <!--Helper javascript methods for initializing webgl-->
    <script src="./lib/webgl-init.js"></script>
    <script src="./lib/webgl-utils.js"></script>
    <script src="./lib/webgl-debug.js"></script>
    <script src="./lib/gl-matrix-min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/cannon@0.6.2/build/cannon.min.js"></script>

    <script>
        function main() {
            // Retrieve <canvas> element
            var canvas = document.getElementById("main_canvas");
            if (!canvas) {
                console.log("Failed to retrieve the <canvas> element");
            }

            let diceSounds = [];
            let diceCollisionFlags = [];

            loadDiceSounds();

            let allDicesAsleep = false;
            let needsValueUpdate = true;
            let lastRollTime = 0;

            // Cylindrical environment parameters
            const CYLINDER_RADIUS = 2.0;   // Radius of the cylinder and floor
            const CYLINDER_HEIGHT = 8.0;   // Conceptual height of the invisible cylinder
            const FLOOR_Y = -0.5;         // Y-position of the floor
            const MAX_DICE = 2;           // Maximum number of dice allowed

            // Dice management
            let diceList = [];

            // Rendering Context
            var gl = initializeWebGL(canvas, true);
            // Initialize Shaders Program
            var vertexShader = initializeShader(gl, "vshader");
            var fragmentShader = initializeShader(gl, "fshader");
            var program = initializeProgram(gl, vertexShader, fragmentShader);
            gl.useProgram(program);

            var aPositionPointer = gl.getAttribLocation(program, "aPosition");
            var aTexCoordPointer = gl.getAttribLocation(program, "aTexCoord")
            gl.enableVertexAttribArray(aPositionPointer);
            gl.enableVertexAttribArray(aTexCoordPointer);

            var colorLocation = gl.getUniformLocation(program, "u_color");


            var uModelMatrixPointer = gl.getUniformLocation(program, "uModelMatrix");
            var uViewMatrixPointer = gl.getUniformLocation(program, "uViewMatrix");
            var uProjectionMatrixPointer = gl.getUniformLocation(program, "uProjectionMatrix");

            // Camera position parameters (editable)
            let eyeX = 0.0; // Original: 1.0
            let eyeY = 6.0; // Original: 2.0
            let eyeZ = 0.5; // Original: 3.0

            var modelMatrix;
            var viewMatrix;
            var projectionMatrix;

            // Projection Matrix Specification
            var fieldOfViewYAxis = glMatrix.toRadian(30);
            var aspectRatio = canvas.width / canvas.height;
            var nearPlane = 1;
            var farPlane = 100;

            // Create floor disk (only visible part of the cylindrical environment)
            function createFloorDisk(numSegments = 64) {
                const verts = [];
                const texCoords = []; // UVs for consistency, though floor will be solid color

                // Center vertex for TRIANGLE_FAN
                verts.push(0, FLOOR_Y, 0, 1.0);
                texCoords.push(0.5, 0.5);

                // Perimeter vertices
                for (let i = 0; i <= numSegments; ++i) {
                    const theta = (i / numSegments) * 2 * Math.PI;
                    verts.push(
                        CYLINDER_RADIUS * Math.cos(theta),
                        FLOOR_Y,
                        CYLINDER_RADIUS * Math.sin(theta),
                        1.0
                    );
                    texCoords.push(
                        0.5 + 0.5 * Math.cos(theta), // Simple planar UV mapping
                        0.5 + 0.5 * Math.sin(theta)
                    );
                }
                return {
                    vertices: new Float32Array(verts),
                    uvCoords: new Float32Array(texCoords),
                    vertexCount: numSegments + 2 // Center + perimeter vertices
                };
            }

            // Generate floor disk geometry and buffers
            const floorDisk = createFloorDisk();

            const floorPositionBuffer = gl.createBuffer();
            gl.bindBuffer(gl.ARRAY_BUFFER, floorPositionBuffer);
            gl.bufferData(gl.ARRAY_BUFFER, floorDisk.vertices, gl.STATIC_DRAW);

            const floorTexCoordBuffer = gl.createBuffer();
            gl.bindBuffer(gl.ARRAY_BUFFER, floorTexCoordBuffer);
            gl.bufferData(gl.ARRAY_BUFFER, floorDisk.uvCoords, gl.STATIC_DRAW);

            // Function to check if a position is outside the cylindrical boundary (for future physics)
            // Assumes objectCenter is an array [x, y, z] and objectRadius is its bounding radius
            function isOutsideCylinder(objectCenter, objectRadius = 0.25) { // Default radius, adjust as needed
                const [x, y, z] = objectCenter;

                // Check floor/ceiling boundaries
                const tooLow = y - objectRadius < FLOOR_Y;
                const tooHigh = y + objectRadius > (FLOOR_Y + CYLINDER_HEIGHT); // Conceptual ceiling

                // Check radial boundary (distance from central Y-axis in XZ plane)
                const distanceFromCenterXZ = Math.hypot(x, z);
                const tooFar = distanceFromCenterXZ + objectRadius > CYLINDER_RADIUS;

                return tooLow || tooHigh || tooFar;
            }

            projectionMatrix = mat4.create();
            mat4.perspective(projectionMatrix, fieldOfViewYAxis, aspectRatio, nearPlane, farPlane);
            gl.uniformMatrix4fv(uProjectionMatrixPointer, false, new Float32Array(projectionMatrix));

            // View Matrix Specification
            var lookAtPoint = [0.0, 0.0, 0.0, 1.0];              //where the camera is looking
            var eyePoint = [eyeX, eyeY, eyeZ, 1.0];        //where the camera is placed
            var upVector = [0.0, 1.0, 0.0, 0.0];              //orientation of the camera

            viewMatrix = mat4.create();
            mat4.lookAt(viewMatrix, eyePoint, lookAtPoint, upVector);
            gl.uniformMatrix4fv(uViewMatrixPointer, false, new Float32Array(viewMatrix));

            // Model Matrix
            modelMatrix = mat4.create();
            modelMatrix = mat4.identity(modelMatrix);
            gl.uniformMatrix4fv(uModelMatrixPointer, false, new Float32Array(modelMatrix));

            //D4 Dice
            var diceFour = [
                0.25, 0.25, 0.25, 1.0,  // V0
                -0.25, -0.25, 0.25, 1.0, // V1
                -0.25, 0.25, -0.25, 1.0, // V2
                0.25, -0.25, -0.25, 1.0  // V3
            ];

            // D4 Face UVs (standard for a triangle)
            const d4FaceUVs = [
                0.5, 1.0, // Top/center vertex of texture
                0.0, 0.0, // Bottom-left vertex of texture
                1.0, 0.0  // Bottom-right vertex of texture
            ];
            const d4FaceUVBuffer = gl.createBuffer();
            gl.bindBuffer(gl.ARRAY_BUFFER, d4FaceUVBuffer);
            gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(d4FaceUVs), gl.STATIC_DRAW);

            let soundsLoaded = false;

            function loadDiceSounds(){
                diceSounds = [];

                const sound1 = new Audio('1-dice.mp3');
                const sound2 = new Audio('1-dice 2.mp3');
                const sound3 = new Audio('1-dice 3.mp3');
                const sound4 = new Audio('1-dice 4.mp3');

                // Add load event listeners to track loading completion
                const soundElements = [sound1, sound2, sound3, sound4];
                let loadedCount = 0;

                soundElements.forEach(sound => {
                        // Handle successful load
                        sound.addEventListener('canplaythrough', function onCanPlay() {
                            loadedCount++;
                            // Remove the event listener to avoid duplicates
                            sound.removeEventListener('canplaythrough', onCanPlay);
                            
                            // Once all sounds are loaded, add them to the array
                            if (loadedCount === soundElements.length) {
                                diceSounds.push(sound1, sound2, sound3, sound4);
                                soundsLoaded = true;
                                console.log("All dice sounds loaded successfully");
                            }
                        });
                        
                        // Handle loading errors
                        sound.addEventListener('error', function(e) {
                            console.error("Error loading sound:", e);
                        });
                        
                        // Initiate loading
                        sound.load();
                    });
                    
                    // Add fallback in case the sounds don't load within 5 seconds
                    setTimeout(() => {
                        if (!soundsLoaded) {
                            console.warn("Sound loading timed out, using empty sounds");
                            // Create silent audio elements as fallback
                            for (let i = 0; i < 4; i++) {
                                const silentSound = new Audio("data:audio/wav;base64,UklGRigAAABXQVZFZm10IBIAAAABAAEARKwAAIhYAQACABAAAABkYXRhAgAAAAEA");
                                diceSounds.push(silentSound);
                            }
                            soundsLoaded = true;
                        }
                    }, 5000);
            }

            function playRandomDiceSound(){
                // Don't try to play sounds if they're not loaded
                if (!soundsLoaded || diceSounds.length === 0) {
                    console.warn("Dice sounds not loaded yet, skipping sound playback");
                    return;
                }
                
                try {
                    const randomIndex = Math.floor(Math.random() * diceSounds.length);
                    // Create a new audio instance to allow overlapping sounds
                    const sound = diceSounds[randomIndex].cloneNode();
                    sound.volume = 1;
                    sound.play().catch(err => {
                        console.warn("Failed to play sound:", err);
                    });
                } catch (err) {
                    console.error("Error playing dice sound:", err);
                }
            }

            // Helper to create D4 face geometry (vertices offset along normal)
            function createD4TexturedFace(vIndices, allVertices, S, offsetAmount) {
                const v = [
                    vec3.fromValues(allVertices[vIndices[0] * 4], allVertices[vIndices[0] * 4 + 1], allVertices[vIndices[0] * 4 + 2]),
                    vec3.fromValues(allVertices[vIndices[1] * 4], allVertices[vIndices[1] * 4 + 1], allVertices[vIndices[1] * 4 + 2]),
                    vec3.fromValues(allVertices[vIndices[2] * 4], allVertices[vIndices[2] * 4 + 1], allVertices[vIndices[2] * 4 + 2])
                ];

                const edge1 = vec3.subtract([], v[1], v[0]);
                const edge2 = vec3.subtract([], v[2], v[0]);
                const normal = vec3.cross([], edge1, edge2);
                vec3.normalize(normal, normal);

                // Ensure normal points outwards (heuristic: dot product with position vector of centroid)
                const centroid = vec3.scale([], vec3.add([], vec3.add([], v[0], v[1]), v[2]), 1 / 3);
                if (vec3.dot(normal, centroid) < 0) {
                    vec3.scale(normal, normal, -1);
                }

                const offsetVec = vec3.scale([], normal, offsetAmount);

                const faceVerts = [];
                for (let i = 0; i < 3; i++) {
                    const v_offset = vec3.add([], v[i], offsetVec);
                    faceVerts.push(v_offset[0], v_offset[1], v_offset[2], 1.0);
                }
                return new Float32Array(faceVerts);
            }

            const d4FaceOffset = 0.01; // How much to offset textured faces

            // Define D4 faces based on indices (V0,V1,V2), (V0,V1,V3), (V0,V2,V3), (V1,V2,V3)
            // These will be associated with textures d4_1, d4_2, d4_3, d4_4 respectively
            const d4Face1Verts = createD4TexturedFace([0, 1, 2], diceFour, 0.25, d4FaceOffset);
            const d4Face2Verts = createD4TexturedFace([0, 1, 3], diceFour, 0.25, d4FaceOffset);
            const d4Face3Verts = createD4TexturedFace([0, 2, 3], diceFour, 0.25, d4FaceOffset);
            const d4Face4Verts = createD4TexturedFace([1, 2, 3], diceFour, 0.25, d4FaceOffset);

            // Buffer for D4 face positions (will be updated for each face)
            const d4TexturedFacePosBuffer = gl.createBuffer();

            // D8 face vertex offsets (the faces will be slightly offset to avoid z-fighting)
            const d8FaceOffset = 0.01;

            // Helper to create D8 face geometry from indices
            function createD8TexturedFace(indices, allVertices, offsetAmount) {
                // Extract the vertices for this face using the indices into the diceEight array
                const v = [
                    vec3.fromValues(allVertices[indices[0] * 4], allVertices[indices[0] * 4 + 1], allVertices[indices[0] * 4 + 2]),
                    vec3.fromValues(allVertices[indices[1] * 4], allVertices[indices[1] * 4 + 1], allVertices[indices[1] * 4 + 2]),
                    vec3.fromValues(allVertices[indices[2] * 4], allVertices[indices[2] * 4 + 1], allVertices[indices[2] * 4 + 2])
                ];

                // Calculate face normal vector
                const edge1 = vec3.subtract([], v[1], v[0]);
                const edge2 = vec3.subtract([], v[2], v[0]);
                const normal = vec3.cross([], edge1, edge2);
                vec3.normalize(normal, normal);

                // Check direction and flip if needed to ensure normal points outward
                const centroid = vec3.scale([], vec3.add([], vec3.add([], v[0], v[1]), v[2]), 1 / 3);
                if (vec3.dot(normal, centroid) < 0) {
                    vec3.scale(normal, normal, -1);
                }

                // Offset vertices along normal
                const offsetVec = vec3.scale([], normal, offsetAmount);
                const faceVerts = [];
                for (let i = 0; i < 3; i++) {
                    const v_offset = vec3.add([], v[i], offsetVec);
                    faceVerts.push(v_offset[0], v_offset[1], v_offset[2], 1.0);
                }

                return new Float32Array(faceVerts);
            }

            // Buffer for D8 face positions (will be updated for each face)
            const d8TexturedFacePosBuffer = gl.createBuffer();

            const d12FaceOffset = 0.01; // How much to offset D12 textured faces

            // D12 pentagon UV coordinates - maps the texture to a pentagon
            const d12FaceUVs = [
                0.5, 1.0,  // Top vertex
                0.0, 0.65, // Upper left
                0.0, 0.15, // Lower left
                1.0, 0.15, // Lower right
                1.0, 0.65  // Upper right
            ];
            const d12FaceUVBuffer = gl.createBuffer();
            gl.bindBuffer(gl.ARRAY_BUFFER, d12FaceUVBuffer);
            gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(d12FaceUVs), gl.STATIC_DRAW);

            // Helper to create D12 face geometry (vertices slightly offset along normal)
            function createD12TexturedFace(indices, allVertices, offsetAmount) {
                // Extract vertices for the pentagon face (each face is 5 vertices)
                const v = [];
                for (let i = 0; i < 5; i++) {
                    v.push(vec3.fromValues(
                        allVertices[indices[i] * 3],
                        allVertices[indices[i] * 3 + 1],
                        allVertices[indices[i] * 3 + 2]
                    ));
                }

                // Calculate face normal by taking cross product of two edges
                const edge1 = vec3.subtract([], v[1], v[0]);
                const edge2 = vec3.subtract([], v[2], v[0]);
                const normal = vec3.cross([], edge1, edge2);
                vec3.normalize(normal, normal);

                // Calculate centroid to ensure normal points outward
                const centroid = [0, 0, 0];
                for (let i = 0; i < 5; i++) {
                    centroid[0] += v[i][0];
                    centroid[1] += v[i][1];
                    centroid[2] += v[i][2];
                }
                centroid[0] /= 5;
                centroid[1] /= 5;
                centroid[2] /= 5;

                if (vec3.dot(normal, centroid) < 0) {
                    vec3.scale(normal, normal, -1); // Ensure normal points outward
                }

                // Offset vertices along normal
                const offsetVec = vec3.scale([], normal, offsetAmount);
                const faceVerts = [];
                for (let i = 0; i < 5; i++) {
                    const v_offset = vec3.add([], v[i], offsetVec);
                    faceVerts.push(v_offset[0], v_offset[1], v_offset[2], 1.0);
                }

                return new Float32Array(faceVerts);
            }

            // Buffer for D12 face positions
            const d12TexturedFacePosBuffer = gl.createBuffer();

            // D6 Dice
            var diceSix = [
                // Front face
                -0.25, -0.25, 0.25, 1.0,
                0.25, -0.25, 0.25, 1.0,
                0.25, 0.25, 0.25, 1.0,
                -0.25, 0.25, 0.25, 1.0,
                // Back face
                -0.25, -0.25, -0.25, 1.0,
                -0.25, 0.25, -0.25, 1.0,
                0.25, 0.25, -0.25, 1.0,
                0.25, -0.25, -0.25, 1.0,
                // Top face
                -0.25, 0.25, -0.25, 1.0,
                -0.25, 0.25, 0.25, 1.0,
                0.25, 0.25, 0.25, 1.0,
                0.25, 0.25, -0.25, 1.0,
                // Bottom face
                -0.25, -0.25, -0.25, 1.0,
                0.25, -0.25, -0.25, 1.0,
                0.25, -0.25, 0.25, 1.0,
                -0.25, -0.25, 0.25, 1.0,
                // Right face
                0.25, -0.25, -0.25, 1.0,
                0.25, 0.25, -0.25, 1.0,
                0.25, 0.25, 0.25, 1.0,
                0.25, -0.25, 0.25, 1.0,
                // Left face
                -0.25, -0.25, -0.25, 1.0,
                -0.25, -0.25, 0.25, 1.0,
                -0.25, 0.25, 0.25, 1.0,
                -0.25, 0.25, -0.25, 1.0
            ];

            // D8 Dice
            var diceEight = [
                0.0, 0.0, 0.5, 1.0,   // Top vertex (doubled from 0.25)
                0.0, 0.0, -0.5, 1.0,  // Bottom vertex (doubled from 0.25)
                0.5, 0.0, 0.0, 1.0,   // Right vertex (doubled from 0.25)
                -0.5, 0.0, 0.0, 1.0,  // Left vertex (doubled from 0.25)
                0.0, 0.5, 0.0, 1.0,   // Front vertex (doubled from 0.25)
                0.0, -0.5, 0.0, 1.0   // Back vertex (doubled from 0.25)
            ];

            // D12 Dice
            // Reference: https://github.com/mrdoob/three.js/blob/master/src/geometries/DodecahedronGeometry.js
            const t = (1 + Math.sqrt(5)) / 2;
            const r = 1 / t;
            var diceTwelve = [
                // (±1, ±1, ±1)
                - 1, - 1, - 1, - 1, - 1, 1,
                - 1, 1, - 1, - 1, 1, 1,
                1, - 1, - 1, 1, - 1, 1,
                1, 1, - 1, 1, 1, 1,

                // (0, ±1/φ, ±φ)
                0, - r, - t, 0, - r, t,
                0, r, - t, 0, r, t,

                // (±1/φ, ±φ, 0)
                - r, - t, 0, - r, t, 0,
                r, - t, 0, r, t, 0,

                // (±φ, 0, ±1/φ)
                - t, 0, - r, t, 0, - r,
                - t, 0, r, t, 0, r
            ]

            // Scale factor to see the shape better
            var rad = 0.25;
            for (let i = 0; i < diceTwelve.length; i++) {
                diceTwelve[i] *= rad;
            }

            // Buffer Creation
            gl.enableVertexAttribArray(aPositionPointer);

            var diceFourBuffer = gl.createBuffer();
            gl.bindBuffer(gl.ARRAY_BUFFER, diceFourBuffer);
            gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(diceFour), gl.STATIC_DRAW);
            gl.vertexAttribPointer(aPositionPointer, 4, gl.FLOAT, false, 0, 0);

            var diceSixBuffer = gl.createBuffer();
            gl.bindBuffer(gl.ARRAY_BUFFER, diceSixBuffer);
            gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(diceSix), gl.STATIC_DRAW);
            gl.vertexAttribPointer(aPositionPointer, 4, gl.FLOAT, false, 0, 0);

            var diceEightBuffer = gl.createBuffer();
            gl.bindBuffer(gl.ARRAY_BUFFER, diceEightBuffer);
            gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(diceEight), gl.STATIC_DRAW);
            gl.vertexAttribPointer(aPositionPointer, 4, gl.FLOAT, false, 0, 0);

            var diceTwelveBuffer = gl.createBuffer();
            gl.bindBuffer(gl.ARRAY_BUFFER, diceTwelveBuffer);
            gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(diceTwelve), gl.STATIC_DRAW);
            gl.vertexAttribPointer(aPositionPointer, 3, gl.FLOAT, false, 0, 0);



            // Index Array for D4
            var diceFourIndices = [
                0, 1, 2,
                0, 1, 3,
                0, 2, 3,
                1, 2, 3
            ];

            // Index Array for D6
            var diceSixIndices = [
                0, 1, 2, 0, 2, 3,    // Front face
                4, 5, 6, 4, 6, 7,    // Back face
                8, 9, 10, 8, 10, 11,  // Top face
                12, 13, 14, 12, 14, 15, // Bottom face
                16, 17, 18, 16, 18, 19, // Right face
                20, 21, 22, 20, 22, 23  // Left face
            ];

            // Index Array for D8
            var diceEightIndices = [
                0, 2, 4,   // Top Side
                0, 4, 3,
                0, 3, 5,
                0, 5, 2,
                1, 2, 4,   // Bottom Side
                1, 3, 4,
                1, 3, 5,
                1, 2, 5
            ];

            // Index Array for D12
            var diceTwelveIndices = [
                3, 11, 7, 3, 7, 15, 3, 15, 13,
                7, 19, 17, 7, 17, 6, 7, 6, 15,
                17, 4, 8, 17, 8, 10, 17, 10, 6,
                8, 0, 16, 8, 16, 2, 8, 2, 10,
                0, 12, 1, 0, 1, 18, 0, 18, 16,
                6, 10, 2, 6, 2, 13, 6, 13, 15,
                2, 16, 18, 2, 18, 3, 2, 3, 13,
                18, 1, 9, 18, 9, 11, 18, 11, 3,
                4, 14, 12, 4, 12, 0, 4, 0, 8,
                11, 9, 5, 11, 5, 19, 11, 19, 7,
                19, 5, 14, 19, 14, 4, 19, 4, 17,
                1, 12, 14, 1, 14, 5, 1, 5, 9
            ]

            // D8 Number Texture
            var diceSixUVFace = [
                0.0, 1.0,
                1.0, 1.0,
                0.0, 0.0,
                1.0, 0.0,
            ]

            // Edge Outlines
            // D4 Edge Outlines
            var diceFourEdges = [
                0, 1,
                0, 2,
                0, 3,
                1, 2,
                1, 3,
                2, 3
            ]

            var diceFourEdgesBuffer = gl.createBuffer();
            gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, diceFourEdgesBuffer);
            gl.bufferData(gl.ELEMENT_ARRAY_BUFFER, new Uint8Array(diceFourEdges), gl.STATIC_DRAW);
            gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, null);

            // D6 Edge Outlines
            var diceSixEdges = [
                0, 1,
                1, 2,
                2, 3,
                3, 0,

                // Back face
                4, 5,
                5, 6,
                6, 7,
                7, 4,

                // Top face
                8, 9,
                9, 10,
                10, 11,
                11, 8,

                // Bottom face
                12, 13,
                13, 14,
                14, 15,
                15, 12,

                // Right face
                16, 17,
                17, 18,
                18, 19,
                19, 16,

                // Left face
                20, 21,
                21, 22,
                22, 23,
                23, 20
            ];

            var diceSixEdgesBuffer = gl.createBuffer();
            gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, diceSixEdgesBuffer);
            gl.bufferData(gl.ELEMENT_ARRAY_BUFFER, new Uint8Array(diceSixEdges), gl.STATIC_DRAW);
            gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, null);

            // D8 Edge Outlines
            var diceEightEdges = [
                // Top
                0, 2,
                0, 4,
                0, 3,
                0, 5,

                // Side or Center
                2, 4,
                3, 4,
                3, 5,
                2, 5,

                // Bottom
                1, 2,
                1, 4,
                1, 3,
                1, 5
            ];

            var diceEightEdgesBuffer = gl.createBuffer();
            gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, diceEightEdgesBuffer);
            gl.bufferData(gl.ELEMENT_ARRAY_BUFFER, new Uint8Array(diceEightEdges), gl.STATIC_DRAW);
            gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, null);

            // Create D8 textured face vertices now that diceEightIndices is defined
            const d8TexturedFaces = [];
            for (let i = 0; i < 8; i++) {
                // Each face in diceEightIndices is defined by 3 indices that are consecutive
                const faceIndices = [
                    diceEightIndices[i * 3],
                    diceEightIndices[i * 3 + 1],
                    diceEightIndices[i * 3 + 2]
                ];
                d8TexturedFaces.push(createD8TexturedFace(faceIndices, diceEight, d8FaceOffset));
            }

            var diceTwelveEdges = [];
            for (let i = 0; i < diceTwelveIndices.length; i += 9) {
                const indices = [
                    diceTwelveIndices[i], diceTwelveIndices[i + 1], diceTwelveIndices[i + 2],
                    diceTwelveIndices[i + 3], diceTwelveIndices[i + 4], diceTwelveIndices[i + 5],
                    diceTwelveIndices[i + 6], diceTwelveIndices[i + 7], diceTwelveIndices[i + 8],
                ];

                // Get unique indices (removing duplicates)
                const uniqueIndices = [...new Set(indices)];

                // Add line segments between consecutive points and wrap around
                for (let j = 0; j < 5; j++) {
                    const a = uniqueIndices[j];
                    const b = uniqueIndices[(j + 1) % 5];
                    diceTwelveEdges.push(a, b);  // store as line segment
                }
            }

            var diceTwelveEdgesBuffer = gl.createBuffer();
            gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, diceTwelveEdgesBuffer);
            gl.bufferData(gl.ELEMENT_ARRAY_BUFFER, new Uint8Array(diceTwelveEdges), gl.STATIC_DRAW);
            gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, null);

            // Create D12 textured faces now that diceTwelveIndices is defined
            const d12TexturedFaces = [];
            // A D12 has 12 pentagonal faces, each defined by 5 unique vertices
            // We need to extract these from the diceTwelveIndices
            for (let i = 0; i < diceTwelveIndices.length; i += 9) {
                // Each 9 indices defines one face in three triangles
                const triangleIndices = [
                    diceTwelveIndices[i], diceTwelveIndices[i + 1], diceTwelveIndices[i + 2],
                    diceTwelveIndices[i + 3], diceTwelveIndices[i + 4], diceTwelveIndices[i + 5],
                    diceTwelveIndices[i + 6], diceTwelveIndices[i + 7], diceTwelveIndices[i + 8]
                ];

                // Extract the unique vertices (5 for a pentagon)
                const uniqueIndices = [...new Set(triangleIndices)];

                // Create the textured face with these unique vertices
                d12TexturedFaces.push(createD12TexturedFace(uniqueIndices, diceTwelve, d12FaceOffset));
            }

            var diceFourIndicesBuffer = gl.createBuffer();
            gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, diceFourIndicesBuffer);
            gl.bufferData(gl.ELEMENT_ARRAY_BUFFER, new Uint8Array(diceFourIndices), gl.STATIC_DRAW);
            gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, null);

            var diceSixIndicesBuffer = gl.createBuffer();
            gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, diceSixIndicesBuffer);
            gl.bufferData(gl.ELEMENT_ARRAY_BUFFER, new Uint8Array(diceSixIndices), gl.STATIC_DRAW);
            gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, null);

            var diceEightIndicesBuffer = gl.createBuffer();
            gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, diceEightIndicesBuffer);
            gl.bufferData(gl.ELEMENT_ARRAY_BUFFER, new Uint8Array(diceEightIndices), gl.STATIC_DRAW);
            gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, null);

            var diceTwelveIndicesBuffer = gl.createBuffer();
            gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, diceTwelveIndicesBuffer);
            gl.bufferData(gl.ELEMENT_ARRAY_BUFFER, new Uint8Array(diceTwelveIndices), gl.STATIC_DRAW);
            gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, null);

            gl.clearColor(0.5, 0.5, 0.5, 1.0);
            gl.clear(gl.COLOR_BUFFER_BIT);
            gl.enable(gl.DEPTH_TEST);

            let currentDice = "diceFour";

            // Texture Loader
            function textureLoader(gl, source, onLoadCallback) {
                const texture = gl.createTexture();
                const image = new Image();
                image.crossOrigin = "anonymous";
                image.src = source;

                image.onload = function () {
                    gl.bindTexture(gl.TEXTURE_2D, texture);
                    gl.pixelStorei(gl.UNPACK_FLIP_Y_WEBGL, true);
                    gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, gl.RGBA, gl.UNSIGNED_BYTE, image);
                    gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE);
                    gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE);
                    gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.LINEAR);

                    onLoadCallback(texture); // Call back with the loaded texture
                };

                return texture;
            }

            let loadedTextures = {};
            let texturesLoaded = 0;
            const TOTAL_TEXTURES_TO_LOAD = 18; // 6 for D6, 4 for D4, 8 for D8

            function onTextureLoaded(name, tex) {
                loadedTextures[name] = tex;
                texturesLoaded++;

                if (texturesLoaded === TOTAL_TEXTURES_TO_LOAD) { // Check if all textures are loaded
                    drawScene(); // Initial draw after all textures are ready
                    animate(); // Start animation loop
                }
            }

            // D6 Textures
            textureLoader(gl, "images/d6/1.png", (tex) => onTextureLoaded("front", tex));
            textureLoader(gl, "images/d6/6.png", (tex) => onTextureLoaded("back", tex));
            textureLoader(gl, "images/d6/2.png", (tex) => onTextureLoaded("top", tex));
            textureLoader(gl, "images/d6/5.png", (tex) => onTextureLoaded("bottom", tex));
            textureLoader(gl, "images/d6/3.png", (tex) => onTextureLoaded("right", tex));
            textureLoader(gl, "images/d6/4.png", (tex) => onTextureLoaded("left", tex));

            // D4 Textures
            textureLoader(gl, "images/d4/1.png", (tex) => onTextureLoaded("d4_1", tex));
            textureLoader(gl, "images/d4/2.png", (tex) => onTextureLoaded("d4_2", tex));
            textureLoader(gl, "images/d4/3.png", (tex) => onTextureLoaded("d4_3", tex));
            textureLoader(gl, "images/d4/4.png", (tex) => onTextureLoaded("d4_4", tex));

            // D8 Textures
            textureLoader(gl, "images/d8/1.png", (tex) => onTextureLoaded("d8_1", tex));
            textureLoader(gl, "images/d8/2.png", (tex) => onTextureLoaded("d8_2", tex));
            textureLoader(gl, "images/d8/3.png", (tex) => onTextureLoaded("d8_3", tex));
            textureLoader(gl, "images/d8/4.png", (tex) => onTextureLoaded("d8_4", tex));
            textureLoader(gl, "images/d8/5.png", (tex) => onTextureLoaded("d8_5", tex));
            textureLoader(gl, "images/d8/6.png", (tex) => onTextureLoaded("d8_6", tex));
            textureLoader(gl, "images/d8/7.png", (tex) => onTextureLoaded("d8_7", tex));
            textureLoader(gl, "images/d8/8.png", (tex) => onTextureLoaded("d8_8", tex));

            //D12 Textures
            textureLoader(gl, "images/d12/1.png", (tex) => onTextureLoaded("d12_1", tex));
            textureLoader(gl, "images/d12/2.png", (tex) => onTextureLoaded("d12_2", tex));
            textureLoader(gl, "images/d12/3.png", (tex) => onTextureLoaded("d12_3", tex));
            textureLoader(gl, "images/d12/4.png", (tex) => onTextureLoaded("d12_4", tex));
            textureLoader(gl, "images/d12/5.png", (tex) => onTextureLoaded("d12_5", tex));
            textureLoader(gl, "images/d12/6.png", (tex) => onTextureLoaded("d12_6", tex));
            textureLoader(gl, "images/d12/7.png", (tex) => onTextureLoaded("d12_7", tex));
            textureLoader(gl, "images/d12/8.png", (tex) => onTextureLoaded("d12_8", tex));
            textureLoader(gl, "images/d12/9.png", (tex) => onTextureLoaded("d12_9", tex));
            textureLoader(gl, "images/d12/10.png", (tex) => onTextureLoaded("d12_10", tex));
            textureLoader(gl, "images/d12/11.png", (tex) => onTextureLoaded("d12_11", tex));
            textureLoader(gl, "images/d12/12.png", (tex) => onTextureLoaded("d12_12", tex));

            // For preventing the textures in being rendered in different dice
            function createBlankTexture(gl) {
                const texture = gl.createTexture();
                gl.bindTexture(gl.TEXTURE_2D, texture);

                const blankPixel = new Uint8Array([0, 0, 0, 0]); // Transparent
                gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, 1, 1, 0, gl.RGBA, gl.UNSIGNED_BYTE, blankPixel);

                return texture;
            }

            const blankTexture = createBlankTexture(gl);

            var diceSixFaceFront = [
                -0.25, 0.25, 0.26, 1.0,
                0.25, 0.25, 0.26, 1.0,
                -0.25, -0.25, 0.26, 1.0,
                0.25, -0.25, 0.26, 1.0
            ];

            var diceSixFaceBack = [
                0.25, 0.25, -0.26, 1.0,
                -0.25, 0.25, -0.26, 1.0,
                0.25, -0.25, -0.26, 1.0,
                -0.25, -0.25, -0.26, 1.0
            ]

            var diceSixFaceTop = [
                -0.25, 0.26, 0.25, 1.0,
                -0.25, 0.26, -0.25, 1.0,
                0.25, 0.26, 0.25, 1.0,
                0.25, 0.26, -0.25, 1.0
            ]

            var diceSixFaceBottom = [
                -0.25, -0.26, 0.25, 1.0,
                0.25, -0.26, 0.25, 1.0,
                -0.25, -0.26, -0.25, 1.0,
                0.25, -0.26, -0.25, 1.0,
            ]

            var diceSixFaceRight = [
                0.26, -0.25, 0.25, 1.0,
                0.26, 0.25, 0.25, 1.0,
                0.26, -0.25, -0.25, 1.0,
                0.26, 0.25, -0.25, 1.0,
            ]

            var diceSixFaceLeft = [
                -0.26, 0.25, 0.25, 1.0,
                -0.26, -0.25, 0.25, 1.0,
                -0.26, 0.25, -0.25, 1.0,
                -0.26, -0.25, -0.25, 1.0,
            ]


                // Initial Rendering (of D4)
                // This initial draw call before animate() might not be needed if onTextureLoaded handles the first draw.
                // gl.bindBuffer(gl.ARRAY_BUFFER, diceFourBuffer);
                // gl.vertexAttribPointer(aPositionPointer, 4, gl.FLOAT, false, 0, 0);
                // gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, diceFourIndicesBuffer);
                // gl.uniform4f(colorLocation,0.7,0.3,0.3,1.0);
                // gl.drawElements(gl.TRIANGLES, diceFourIndices.length, gl.UNSIGNED_BYTE, 0);
                
                // For Rotation
                let rotationSpeed = 0.005;
                let isRotating = true;

                // Get the value of the D4 Dice
                // ONLY CALL THIS AFTER THE ROLL
                function getTopD4Value(modelMatrix) {
                    const diceFourPerVer = [
                        [ 0.25,  0.25,  0.25, 1.0],  // V0
                        [-0.25, -0.25,  0.25, 1.0],  // V1
                        [-0.25,  0.25, -0.25, 1.0],  // V2
                        [ 0.25, -0.25, -0.25, 1.0]   // V3
                    ];

                    let maxY = -Infinity;
                    let topVertexIndex = -1;

                    for (let i = 0; i < diceFourPerVer.length; i++) {
                        const v = diceFourPerVer[i];
                        const vertex = vec4.fromValues(v[0], v[1], v[2], v[3]);
                        const transformed = vec4.create();
                        vec4.transformMat4(transformed, vertex, modelMatrix);

                        if (transformed[1] > maxY) {
                            maxY = transformed[1];
                            topVertexIndex = i;
                        }
                    }

                    const valueMap = [4, 1, 2, 3];
                    return valueMap[topVertexIndex];
                }


                // Get the value of the D6 Dice
                // ONLY CALL THIS AFTER THE ROLL
                function getTopD6Value () {
                    const faceCenters = {
                        front:  [ 0.0,  0.0,  0.25, 1.0],
                        back:   [ 0.0,  0.0, -0.25, 1.0],
                        top:    [ 0.0,  0.25,  0.0,  1.0],
                        bottom: [ 0.0, -0.25,  0.0,  1.0],
                        right:  [ 0.25, 0.0,  0.0,  1.0],
                        left:   [-0.25, 0.0,  0.0,  1.0]
                    };

                    // Map face names to die values based on texture mapping
                    const faceToValue = {
                        top: 2,
                        bottom: 5,
                        front: 1,
                        back: 6,
                        right: 3,
                        left: 4
                    };

                    let topFace = null;
                    let maxY = -Infinity;

                    for (const [face, center] of Object.entries(faceCenters)) {
                        const transformed = vec4.create();
                        const original = vec4.fromValues(...center);
                        vec4.transformMat4(transformed, original, modelMatrix);

                        if (transformed[1] > maxY) {
                            maxY = transformed[1];
                            topFace = face;
                        }
                    }

                    return faceToValue[topFace];
                }

                // Get the value of the D8 Dice
                // ONLY CALL THIS AFTER THE ROLL
                function getTopD8Value(modelMatrix) {
                    let maxY = -Infinity;
                    let topFaceIndex = -1;

                    // Each face is 3 indices, so loop in steps of 3
                    for (let i = 0; i < diceEightIndices.length; i += 3) {
                        const idx0 = diceEightIndices[i] * 4;
                        const idx1 = diceEightIndices[i + 1] * 4;
                        const idx2 = diceEightIndices[i + 2] * 4;

                        const v0 = vec4.fromValues(
                            diceEight[idx0], diceEight[idx0 + 1], diceEight[idx0 + 2], diceEight[idx0 + 3]
                        );
                        const v1 = vec4.fromValues(
                            diceEight[idx1], diceEight[idx1 + 1], diceEight[idx1 + 2], diceEight[idx1 + 3]
                        );
                        const v2 = vec4.fromValues(
                            diceEight[idx2], diceEight[idx2 + 1], diceEight[idx2 + 2], diceEight[idx2 + 3]
                        );

                        // Average the three vertices to get the center point of the face
                        const center = vec4.fromValues(
                            (v0[0] + v1[0] + v2[0]) / 3,
                            (v0[1] + v1[1] + v2[1]) / 3,
                            (v0[2] + v1[2] + v2[2]) / 3,
                            1.0
                        );

                        // Transform the center using modelMatrix
                        const transformedCenter = vec4.create();
                        vec4.transformMat4(transformedCenter, center, modelMatrix);

                        if (transformedCenter[1] > maxY) {
                            maxY = transformedCenter[1];
                            topFaceIndex = i / 3;
                        }
                    }

                    const valueMap = [1, 2, 3, 4, 5, 6, 7, 8];
                    const topValue = valueMap[topFaceIndex];

                    return topValue;
                }


                 // Get the value of the D12 Dice
                // ONLY CALL THIS AFTER THE ROLL
                function getTopD12Value(modelMatrix) {
                    let maxY = -Infinity;
                    let topFaceIndex = -1;

                    // D12 vertex positions use 3 components per vertex
                    const numTriangles = diceTwelveIndices.length / 3;

                    for (let i = 0; i < diceTwelveIndices.length; i += 3) {
                        const idx0 = diceTwelveIndices[i] * 3;
                        const idx1 = diceTwelveIndices[i + 1] * 3;
                        const idx2 = diceTwelveIndices[i + 2] * 3;

                        const v0 = vec4.fromValues(
                            diceTwelve[idx0], diceTwelve[idx0 + 1], diceTwelve[idx0 + 2], 1.0
                        );
                        const v1 = vec4.fromValues(
                            diceTwelve[idx1], diceTwelve[idx1 + 1], diceTwelve[idx1 + 2], 1.0
                        );
                        const v2 = vec4.fromValues(
                            diceTwelve[idx2], diceTwelve[idx2 + 1], diceTwelve[idx2 + 2], 1.0
                        );

                        // Compute face center
                        const center = vec4.fromValues(
                            (v0[0] + v1[0] + v2[0]) / 3,
                            (v0[1] + v1[1] + v2[1]) / 3,
                            (v0[2] + v1[2] + v2[2]) / 3,
                            1.0
                        );

                        // Transform the center using model matrix
                        const transformedCenter = vec4.create();
                        vec4.transformMat4(transformedCenter, center, modelMatrix);

                        // Track highest Y
                        if (transformedCenter[1] > maxY) {
                            maxY = transformedCenter[1];
                            topFaceIndex = Math.floor(i / 9); // 9 indices = 3 triangles per pentagon
                        }
                    }

                    const faceValues = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12];
                    return faceValues[topFaceIndex];
                }


            // // Get the value of the D4 Dice
            // // ONLY CALL THIS AFTER THE ROLL
            // function getTopD4Value(modelMatrix) {
            //     const diceFourPerVer = [
            //         [ 0.25,  0.25,  0.25, 1.0],  // V0
            //         [-0.25, -0.25,  0.25, 1.0],  // V1
            //         [-0.25,  0.25, -0.25, 1.0],  // V2
            //         [ 0.25, -0.25, -0.25, 1.0]   // V3
            //     ];

            //     let maxY = -Infinity;
            //     let topVertexIndex = -1;

            //     for (let i = 0; i < diceFourPerVer.length; i++) {
            //         const v = diceFourPerVer[i];
            //         const vertex = vec4.fromValues(v[0], v[1], v[2], v[3]);
            //         const transformed = vec4.create();
            //         vec4.transformMat4(transformed, vertex, modelMatrix);

            //         if (transformed[1] > maxY) {
            //             maxY = transformed[1];
            //             topVertexIndex = i;
            //         }
            //     }

            //     const valueMap = [1, 3, 4, 2];
            //     return valueMap[topVertexIndex];
            // }

            // // Get the value of the D6 Dice
            // // ONLY CALL THIS AFTER THE ROLL
            // function getTopD6Value(modelMatrix) {
            //     const faceCenters = {
            //         front:  [ 0.0,  0.0,  0.25, 1.0],
            //         back:   [ 0.0,  0.0, -0.25, 1.0],
            //         top:    [ 0.0,  0.25,  0.0,  1.0],
            //         bottom: [ 0.0, -0.25,  0.0,  1.0],
            //         right:  [ 0.25, 0.0,  0.0,  1.0],
            //         left:   [-0.25, 0.0,  0.0,  1.0]
            //     };

            //     // Map face names to die values based on texture mapping
            //     const faceToValue = {
            //         top: 2,
            //         bottom: 5,
            //         front: 1,
            //         back: 6,
            //         right: 3,
            //         left: 4
            //     };

            //     let topFace = null;
            //     let maxY = -Infinity;

            //     for (const [face, center] of Object.entries(faceCenters)) {
            //         const transformed = vec4.create();
            //         const original = vec4.fromValues(...center);
            //         vec4.transformMat4(transformed, original, modelMatrix);

            //         if (transformed[1] > maxY) {
            //             maxY = transformed[1];
            //             topFace = face;
            //         }
            //     }

            //     return faceToValue[topFace];
            // }

            // // Get the value of the D8 Dice
            // // ONLY CALL THIS AFTER THE ROLL
            // function getTopD8Value(modelMatrix) {
            //     let maxY = -Infinity;
            //     let topFaceIndex = -1;

            //     // Each face is 3 indices, so loop in steps of 3
            //     for (let i = 0; i < diceEightIndices.length; i += 3) {
            //         const idx0 = diceEightIndices[i] * 4;
            //         const idx1 = diceEightIndices[i + 1] * 4;
            //         const idx2 = diceEightIndices[i + 2] * 4;

            //         const v0 = vec4.fromValues(
            //             diceEight[idx0], diceEight[idx0 + 1], diceEight[idx0 + 2], diceEight[idx0 + 3]
            //         );
            //         const v1 = vec4.fromValues(
            //             diceEight[idx1], diceEight[idx1 + 1], diceEight[idx1 + 2], diceEight[idx1 + 3]
            //         );
            //         const v2 = vec4.fromValues(
            //             diceEight[idx2], diceEight[idx2 + 1], diceEight[idx2 + 2], diceEight[idx2 + 3]
            //         );

            //         // Average the three vertices to get the center point of the face
            //         const center = vec4.fromValues(
            //             (v0[0] + v1[0] + v2[0]) / 3,
            //             (v0[1] + v1[1] + v2[1]) / 3,
            //             (v0[2] + v1[2] + v2[2]) / 3,
            //             1.0
            //         );

            //         // Transform the center using modelMatrix
            //         const transformedCenter = vec4.create();
            //         vec4.transformMat4(transformedCenter, center, modelMatrix);

            //         if (transformedCenter[1] > maxY) {
            //             maxY = transformedCenter[1];
            //             topFaceIndex = i / 3;
            //         }
            //     }

            //     const valueMap = [1, 2, 3, 4, 5, 6, 7, 8];
            //     const topValue = valueMap[topFaceIndex];

            //     return topValue;
            // }

            // // Get the value of the D12 Dice
            // // ONLY CALL THIS AFTER THE ROLL
            // function getTopD12Value(modelMatrix) {
            //     let maxY = -Infinity;
            //     let topFaceIndex = -1;

            //     // D12 vertex positions use 3 components per vertex
            //     const numTriangles = diceTwelveIndices.length / 3;

            //     for (let i = 0; i < diceTwelveIndices.length; i += 3) {
            //         const idx0 = diceTwelveIndices[i] * 3;
            //         const idx1 = diceTwelveIndices[i + 1] * 3;
            //         const idx2 = diceTwelveIndices[i + 2] * 3;

            //         const v0 = vec4.fromValues(
            //             diceTwelve[idx0], diceTwelve[idx0 + 1], diceTwelve[idx0 + 2], 1.0
            //         );
            //         const v1 = vec4.fromValues(
            //             diceTwelve[idx1], diceTwelve[idx1 + 1], diceTwelve[idx1 + 2], 1.0
            //         );
            //         const v2 = vec4.fromValues(
            //             diceTwelve[idx2], diceTwelve[idx2 + 1], diceTwelve[idx2 + 2], 1.0
            //         );

            //         // Compute face center
            //         const center = vec4.fromValues(
            //             (v0[0] + v1[0] + v2[0]) / 3,
            //             (v0[1] + v1[1] + v2[1]) / 3,
            //             (v0[2] + v1[2] + v2[2]) / 3,
            //             1.0
            //         );

            //         // Transform the center using model matrix
            //         const transformedCenter = vec4.create();
            //         vec4.transformMat4(transformedCenter, center, modelMatrix);

            //         // Track highest Y
            //         if (transformedCenter[1] > maxY) {
            //             maxY = transformedCenter[1];
            //             topFaceIndex = Math.floor(i / 9); // 9 indices = 3 triangles per pentagon
            //         }
            //     }

            //     const faceValues = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12];
            //     return faceValues[topFaceIndex];
            // }

            // Function to check and display dice values when they've stopped moving
            function checkDiceValues() {
                // If all dice were already asleep and nothing changed, skip processing
                if (allDicesAsleep && !needsValueUpdate) {
                    return true;
                }
                
                const stoppedDice = [];
                let allStopped = true;
                let allSleeping = true;
                
                // Check if all dice have stopped moving
                for (let i = 0; i < diceList.length; i++) {
                    const dice = diceList[i];
                    if (!dice.body) continue;
                    
                    // Check sleeping state
                    if (dice.body.sleepState === CANNON.Body.SLEEPING) {
                        // Add to stoppedDice without recalculating if we've already done it
                        if (!dice.valueCalculated || needsValueUpdate) {
                            // Only calculate the value once
                            const pos = dice.body.position;
                            const quat = dice.body.quaternion;
                            
                            const diceModelMatrix = mat4.create();
                            mat4.translate(diceModelMatrix, diceModelMatrix, [pos.x, pos.y, pos.z]);
                            
                            const rotationMatrix = mat4.create();
                            mat4.fromQuat(rotationMatrix, [quat.x, quat.y, quat.z, quat.w]);
                            mat4.multiply(diceModelMatrix, diceModelMatrix, rotationMatrix);
                            
                            // Calculate value based on dice type
                            let value;
                            switch (dice.type) {
                                case "diceFour": value = getTopD4Value(diceModelMatrix); break;
                                case "diceSix": value = getTopD6Value(diceModelMatrix); break;
                                case "diceEight": value = getTopD8Value(diceModelMatrix); break;
                                case "diceTwelve": value = getTopD12Value(diceModelMatrix); break;
                            }
                            
                            dice.valueCalculated = true;
                            dice.value = value;
                        }
                        
                        stoppedDice.push({
                            type: dice.type,
                            value: dice.value
                        });
                    } else {
                        // This die is not sleeping
                        allSleeping = false;
                        
                        // Reset values for moving dice
                        if (dice.valueCalculated) {
                            dice.valueCalculated = false;
                        }
                        
                        // Consider a die stopped if both linear and angular velocity are below threshold
                        const linVelMagnitude = dice.body.velocity.lengthSquared();
                        const angVelMagnitude = dice.body.angularVelocity.lengthSquared();
                        
                        const isStopped = linVelMagnitude < 0.01 && angVelMagnitude < 0.01;
                        
                        if (isStopped) {
                            // Create model matrix for the die to calculate its value
                            const pos = dice.body.position;
                            const quat = dice.body.quaternion;
                            
                            const diceModelMatrix = mat4.create();
                            mat4.translate(diceModelMatrix, diceModelMatrix, [pos.x, pos.y, pos.z]);
                            
                            // Apply rotation from physics quaternion
                            const rotationMatrix = mat4.create();
                            mat4.fromQuat(rotationMatrix, [quat.x, quat.y, quat.z, quat.w]);
                            mat4.multiply(diceModelMatrix, diceModelMatrix, rotationMatrix);
                            
                            // Get value based on dice type
                            let value;
                            switch (dice.type) {
                                case "diceFour":
                                    value = getTopD4Value(diceModelMatrix);
                                    break;
                                case "diceSix":
                                    value = getTopD6Value(diceModelMatrix);
                                    break;
                                case "diceEight":
                                    value = getTopD8Value(diceModelMatrix);
                                    break;
                                case "diceTwelve":
                                    value = getTopD12Value(diceModelMatrix);
                                    break;
                            }
                            
                            stoppedDice.push({
                                type: dice.type,
                                value: value
                            });
                        } else {
                            allStopped = false;
                        }
                    }
                }
                
                // Update the display only if dice values changed or we need to update
                if (stoppedDice.length > 0 || needsValueUpdate) {
                    // Display values on screen
                    const diceValuesDisplay = document.getElementById('diceValues');
                    if (diceValuesDisplay) {
                        // Convert dice names to more readable format
                        const prettyNames = {
                            "diceFour": "D4",
                            "diceSix": "D6", 
                            "diceEight": "D8",
                            "diceTwelve": "D12"
                        };
                        
                        // Get total of all dice
                        const total = stoppedDice.reduce((sum, die) => sum + die.value, 0);
                        
                        // Format the display text
                        let displayText = stoppedDice.map(d => 
                            `${prettyNames[d.type]}: ${d.value}`
                        ).join(" + ");
                        
                        // Add total if more than one die
                        if (stoppedDice.length > 1) {
                            displayText += ` = ${total}`;
                        }
                        
                        diceValuesDisplay.textContent = displayText;
                    }
                } else if (allStopped && diceList.length === 0) {
                    // Clear display when no dice
                    const diceValuesDisplay = document.getElementById('diceValues');
                    if (diceValuesDisplay) {
                        diceValuesDisplay.textContent = "";
                    }
                }
                
                // If all dice are asleep, we can stop checking values until they wake up
                allDiceAsleep = allSleeping && diceList.length > 0;
                if (allDiceAsleep) {
                    needsValueUpdate = false; // Values are now up to date
                }
                
                return allStopped;
            }

            // setting up of physics
            const world = new CANNON.World();
            world.gravity.set(0, -15.82, 0); // increased gravity from (-9.82) earth's gravity to not make the dice look gigantic
            world.broadphase = new CANNON.NaiveBroadphase();
            world.solver.iterations = 15; // Higher == more accurate but slower
            world.defaultContactMaterial.contactEquationStiffness = 1e6; // Stiffer contacts
            world.defaultContactMaterial.contactEquationRelaxation = 4;  // More relaxation

            // Add these parameters to your world initialization around line 848
            world.allowSleep = true;
            world.sleepTimeLimit = 0.015; // Time (seconds) object must be still before sleeping
            world.sleepSpeedLimit = 0.05; // Speed limit below which object is considered still

            // materials for collisions
            const diceMaterial = new CANNON.Material("diceMaterial");
            const floorMaterial = new CANNON.Material("floorMaterial");
            const wallMaterial = new CANNON.Material("wallMaterial");

            // contact materials
            const diceFloorContact = new CANNON.ContactMaterial(
                diceMaterial, floorMaterial, {
                    friction: 0.5, //slipperiness
                    restitution: 0.5// bounce
                }
            )

            const diceWallConstact = new CANNON.ContactMaterial(
                diceMaterial, wallMaterial, {
                    friction: 0.0, // frictionless
                    restitution: 0.7 
                }
            )

            const diceDiceContact = new CANNON.ContactMaterial(
                diceMaterial, diceMaterial, {
                    friction: 0.2,
                    restitution: 0.3
                }
            );
            world.addContactMaterial(diceDiceContact);
            world.addContactMaterial(diceFloorContact)
            world.addContactMaterial(diceWallConstact)

            // floor collision
            const floorBody = new CANNON.Body({
                mass: 0, //static
                material: floorMaterial,
                shape: new CANNON.Plane(),
                position: new CANNON.Vec3(0, FLOOR_Y, 0)
            })

            // horizaontally rotate the plane
            floorBody.quaternion.setFromAxisAngle(new CANNON.Vec3(1,0,0), -Math.PI/2);
            world.addBody(floorBody);

            // cylindrical wall
            const wallSegments = 16;
            for (let i = 0; i < wallSegments; i++){
                const angle = (i/wallSegments) * Math.PI * 2;

                // calculate normal pointing inward
                const nx = -Math.cos(angle);
                const nz = -Math.sin(angle);

                const wallBody = new CANNON.Body({
                    mass: 0,
                    material: wallMaterial,
                    shape: new CANNON.Plane(),
                    position: new CANNON.Vec3(
                        Math.cos(angle) * CYLINDER_RADIUS,
                        FLOOR_Y + CYLINDER_HEIGHT/2,
                        Math.sin(angle) * CYLINDER_RADIUS
                    )
                })

                // orient the plane to face inward
                const q = new CANNON.Quaternion();
                q.setFromVectors(new CANNON.Vec3(0,0,1), new CANNON.Vec3(nx,0,nz));
                wallBody.quaternion = q;

                world.addBody(wallBody);
            }

            let lastTime = 0;
            function animate(currentTime) {
                // Convert to seconds
                const timeInSeconds = currentTime * 0.001;
                let deltaTime = lastTime ? timeInSeconds - lastTime : 1/60;
                lastTime = timeInSeconds;
                
                // Cap deltaTime for stability
                if (deltaTime > 0.1) deltaTime = 0.1;

                // Apply manual rotation to floating dice
                for (let i = 0; i < diceList.length; i++) {
                    const dice = diceList[i];
                    if (dice.floating && dice.body) {
                        // Keep position fixed (cancel any minor gravity effects)
                        dice.body.velocity.set(0, 0, 0);
                        
                        // Create rotation quaternion
                        const axis = dice.rotationAxis;
                        const axisNorm = Math.sqrt(axis[0]*axis[0] + axis[1]*axis[1] + axis[2]*axis[2]);
                        const normAxis = [
                            axis[0] / axisNorm,
                            axis[1] / axisNorm,
                            axis[2] / axisNorm
                        ];
                        
                        const rotQ = new CANNON.Quaternion();
                        rotQ.setFromAxisAngle(
                            new CANNON.Vec3(normAxis[0], normAxis[1], normAxis[2]),
                            rotationSpeed
                        );
                        
                        // Apply rotation to the body
                        dice.body.quaternion = dice.body.quaternion.mult(rotQ);
                    }
                }
                
                // Step physics world
                world.step(1/60, deltaTime, 10);
                forceSleepIfNeeded();
                
                // Check dice values every frame when dice are settling
                // This is more responsive than checking only once per second
                const allStopped = checkDiceValues();
                

                drawScene();
                requestAnimationFrame(animate);
            }


            function drawScene() {
                gl.clearColor(0, 0, 0, 1.0);
                gl.clear(gl.COLOR_BUFFER_BIT | gl.DEPTH_BUFFER_BIT); // Added DEPTH_BUFFER_BIT

                // --- Draw the Floor Disk ---
                gl.uniform1i(gl.getUniformLocation(program, "uUseTexture"), false); // Tell shader not to use texture

                // Set model matrix for the floor (identity, so it doesn't move/rotate with dice)
                const floorModelMatrix = mat4.create(); // Identity matrix
                gl.uniformMatrix4fv(uModelMatrixPointer, false, floorModelMatrix);

                // Bind floor vertex data
                gl.bindBuffer(gl.ARRAY_BUFFER, floorPositionBuffer);
                gl.vertexAttribPointer(aPositionPointer, 4, gl.FLOAT, false, 0, 0);
                gl.enableVertexAttribArray(aPositionPointer);

                // Bind floor UV data (even if not used, good practice to have it bound if attrib is enabled elsewhere)
                gl.bindBuffer(gl.ARRAY_BUFFER, floorTexCoordBuffer);
                gl.vertexAttribPointer(aTexCoordPointer, 2, gl.FLOAT, false, 0, 0);
                gl.enableVertexAttribArray(aTexCoordPointer); // Keep it enabled

                // Set floor color to white
                gl.uniform4f(colorLocation, 0.2, 0.711, 0.945, 1.0);

                // Draw the floor
                gl.drawArrays(gl.TRIANGLE_FAN, 0, floorDisk.vertexCount);

                // --- Restore Dice Model Matrix and Draw Dice ---
                gl.uniformMatrix4fv(uModelMatrixPointer, false, modelMatrix); // Restore original modelMatrix for dice

                // Draw all dice in the diceList
                for (let i = 0; i < diceList.length; i++) {
                    const dice = diceList[i];

                    if (!dice.body) continue; // skip dice withoutt physics bodies

                    // Get position and orientation from physics body
                    const pos = dice.body.position;
                    const quat = dice.body.quaternion;

                    // create model matrix for the die
                    const diceModelMatrix = mat4.create();
                    mat4.translate(diceModelMatrix, diceModelMatrix, [pos.x, pos.y, pos.z]);
                    // Apply rotation from physics quaternion
                    const rotationMatrix = mat4.create();
                    mat4.fromQuat(rotationMatrix, [quat.x, quat.y, quat.z, quat.w]);
                    mat4.multiply(diceModelMatrix, diceModelMatrix, rotationMatrix);

                    // Apply to shader
                    gl.uniformMatrix4fv(uModelMatrixPointer, false, diceModelMatrix);

                    if (dice.type === "diceFour") drawD4();
                    else if (dice.type === "diceSix") drawD6();
                    else if (dice.type === "diceEight") drawD8();
                    else if (dice.type === "diceTwelve") drawD12();

                }

                // Call this at the beginning of drawScene()
                function resetFallenDice() {
                    for (let i = 0; i < diceList.length; i++) {
                        const dice = diceList[i];
                        if (dice.body && dice.body.position.y < FLOOR_Y - 5) {
                            // Reset position if dice fell through the floor
                            dice.body.position.set(
                                (Math.random() - 0.5) * CYLINDER_RADIUS * 0.5, 
                                FLOOR_Y + 3, 
                                (Math.random() - 0.5) * CYLINDER_RADIUS * 0.5
                            );
                            dice.body.velocity.set(0, 0, 0);
                            dice.body.angularVelocity.set(0, 0, 0);
                            
                            // Random toss
                            dice.body.velocity.set(
                                (Math.random() - 0.5) * 3,
                                -1 - Math.random() * 2,
                                (Math.random() - 0.5) * 3
                            );
                            
                            dice.body.angularVelocity.set(
                                (Math.random() - 0.5) * 5,
                                (Math.random() - 0.5) * 5,
                                (Math.random() - 0.5) * 5
                            );
                        }
                    }
                }

                //draw part
                function drawD4() {
                    gl.uniform1i(gl.getUniformLocation(program, "uUseTexture"), false);

                    // Draw solid D4 base
                    gl.bindBuffer(gl.ARRAY_BUFFER, diceFourBuffer);
                    gl.vertexAttribPointer(aPositionPointer, 4, gl.FLOAT, false, 0, 0);
                    gl.enableVertexAttribArray(aPositionPointer); // Ensure it's enabled

                    gl.uniform4f(colorLocation, 0.7, 0.3, 0.3, 1.0); // D4 base color
                    gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, diceFourIndicesBuffer);
                    gl.drawElements(gl.TRIANGLES, diceFourIndices.length, gl.UNSIGNED_BYTE, 0);

                    // Draw D4 edges
                    gl.uniform4f(colorLocation, 1.0, 1.0, 1.0, 1.0); // Edge color
                    gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, diceFourEdgesBuffer);
                    gl.drawElements(gl.LINES, diceFourEdges.length, gl.UNSIGNED_BYTE, 0);

                    // --- Draw Textured D4 Faces ---
                    gl.uniform1i(gl.getUniformLocation(program, "uUseTexture"), true);

                    gl.bindBuffer(gl.ARRAY_BUFFER, d4FaceUVBuffer); // Use common UV buffer for all D4 faces
                    gl.vertexAttribPointer(aTexCoordPointer, 2, gl.FLOAT, false, 0, 0);
                    gl.enableVertexAttribArray(aTexCoordPointer);

                    const facesVerts = [d4Face1Verts, d4Face2Verts, d4Face3Verts, d4Face4Verts];
                    const faceTextures = ["d4_1", "d4_2", "d4_3", "d4_4"];

                    for (let i = 0; i < 4; i++) {
                        gl.bindBuffer(gl.ARRAY_BUFFER, d4TexturedFacePosBuffer);
                        gl.bufferData(gl.ARRAY_BUFFER, facesVerts[i], gl.DYNAMIC_DRAW); // Update buffer data
                        gl.vertexAttribPointer(aPositionPointer, 4, gl.FLOAT, false, 0, 0);
                        // aPositionPointer should still be enabled from drawing the base

                        gl.activeTexture(gl.TEXTURE0);
                        gl.bindTexture(gl.TEXTURE_2D, loadedTextures[faceTextures[i]]);
                        gl.uniform1i(gl.getUniformLocation(program, "uSampler"), 0);

                        gl.drawArrays(gl.TRIANGLES, 0, 3); // Each face is 3 vertices
                    }

                }

                function drawD6() {
                    gl.uniform1i(gl.getUniformLocation(program, "uUseTexture"), false);

                    gl.bindBuffer(gl.ARRAY_BUFFER, diceSixBuffer);
                    gl.vertexAttribPointer(aPositionPointer, 4, gl.FLOAT, false, 0, 0);

                    gl.uniform4f(colorLocation, 0.0, 0.0, 0.0, 1.0);
                    gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, diceSixIndicesBuffer);
                    gl.drawElements(gl.TRIANGLES, diceSixIndices.length, gl.UNSIGNED_BYTE, 0);

                    gl.uniform4f(colorLocation, 1.0, 1.0, 1.0, 1.0);
                    gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, diceSixEdgesBuffer);
                    gl.drawElements(gl.LINES, diceSixEdges.length, gl.UNSIGNED_BYTE, 0);

                    // Rendering Texture ==================================================================
                    // === FRONT FACE ===
                    gl.uniform1i(gl.getUniformLocation(program, "uUseTexture"), true);

                    // === Setup Buffers ===
                    const positionBuffer = gl.createBuffer();
                    const uvBuffer = gl.createBuffer();

                    gl.bindBuffer(gl.ARRAY_BUFFER, uvBuffer);
                    gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(diceSixUVFace), gl.STATIC_DRAW);
                    gl.enableVertexAttribArray(aTexCoordPointer);
                    gl.vertexAttribPointer(aTexCoordPointer, 2, gl.FLOAT, false, 0, 0);

                    gl.bindBuffer(gl.ARRAY_BUFFER, positionBuffer);
                    gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(diceSixFaceFront), gl.STATIC_DRAW);
                    gl.enableVertexAttribArray(aPositionPointer);
                    gl.vertexAttribPointer(aPositionPointer, 4, gl.FLOAT, false, 0, 0);

                    gl.activeTexture(gl.TEXTURE0);
                    gl.bindTexture(gl.TEXTURE_2D, loadedTextures["front"]);
                    gl.uniform1i(gl.getUniformLocation(program, "uSampler"), 0);

                    gl.drawArrays(gl.TRIANGLE_STRIP, 0, 4);

                    // === BACK FACE ===
                    gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(diceSixFaceBack), gl.STATIC_DRAW);

                    gl.activeTexture(gl.TEXTURE0);
                    gl.bindTexture(gl.TEXTURE_2D, loadedTextures["back"]);
                    gl.uniform1i(gl.getUniformLocation(program, "uSampler"), 0);

                    gl.drawArrays(gl.TRIANGLE_STRIP, 0, 4);

                    // === TOP FACE ===
                    gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(diceSixFaceTop), gl.STATIC_DRAW);

                    gl.activeTexture(gl.TEXTURE0);
                    gl.bindTexture(gl.TEXTURE_2D, loadedTextures["top"]);
                    gl.uniform1i(gl.getUniformLocation(program, "uSampler"), 0);

                    gl.drawArrays(gl.TRIANGLE_STRIP, 0, 4);

                    // === BOTTOM FACE ===
                    gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(diceSixFaceBottom), gl.STATIC_DRAW);

                    gl.activeTexture(gl.TEXTURE0);
                    gl.bindTexture(gl.TEXTURE_2D, loadedTextures["bottom"]);
                    gl.uniform1i(gl.getUniformLocation(program, "uSampler"), 0);

                    gl.drawArrays(gl.TRIANGLE_STRIP, 0, 4);

                    // === RIGHT FACE ===
                    gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(diceSixFaceRight), gl.STATIC_DRAW);

                    gl.activeTexture(gl.TEXTURE0);
                    gl.bindTexture(gl.TEXTURE_2D, loadedTextures["right"]);
                    gl.uniform1i(gl.getUniformLocation(program, "uSampler"), 0);

                    gl.drawArrays(gl.TRIANGLE_STRIP, 0, 4);

                    // === LEFT FACE ===
                    gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(diceSixFaceLeft), gl.STATIC_DRAW);

                    gl.activeTexture(gl.TEXTURE0);
                    gl.bindTexture(gl.TEXTURE_2D, loadedTextures["left"]);
                    gl.uniform1i(gl.getUniformLocation(program, "uSampler"), 0);

                    gl.drawArrays(gl.TRIANGLE_STRIP, 0, 4);

                }

                function drawD8() {
                    gl.uniform1i(gl.getUniformLocation(program, "uUseTexture"), false);

                    // Draw solid D8 base
                    gl.bindBuffer(gl.ARRAY_BUFFER, diceEightBuffer);
                    gl.vertexAttribPointer(aPositionPointer, 4, gl.FLOAT, false, 0, 0);

                    gl.uniform4f(colorLocation, 0.3, 0.3, 0.7, 1.0);
                    gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, diceEightIndicesBuffer);
                    gl.drawElements(gl.TRIANGLES, diceEightIndices.length, gl.UNSIGNED_BYTE, 0);

                    // Draw D8 edges
                    gl.uniform4f(colorLocation, 1.0, 1.0, 1.0, 1.0);
                    gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, diceEightEdgesBuffer);
                    gl.drawElements(gl.LINES, diceEightEdges.length, gl.UNSIGNED_BYTE, 0);

                    // --- Draw Textured D8 Faces ---
                    gl.uniform1i(gl.getUniformLocation(program, "uUseTexture"), true);

                    gl.bindBuffer(gl.ARRAY_BUFFER, d4FaceUVBuffer); // Reuse the D4 UV buffer as they're both triangular faces
                    gl.vertexAttribPointer(aTexCoordPointer, 2, gl.FLOAT, false, 0, 0);
                    gl.enableVertexAttribArray(aTexCoordPointer);

                    const d8FaceTextures = [
                        "d8_1", "d8_2", "d8_3", "d8_4", "d8_5", "d8_6", "d8_7", "d8_8"
                    ];

                    for (let i = 0; i < 8; i++) {
                        // Update buffer with this face's vertices
                        gl.bindBuffer(gl.ARRAY_BUFFER, d8TexturedFacePosBuffer);
                        gl.bufferData(gl.ARRAY_BUFFER, d8TexturedFaces[i], gl.DYNAMIC_DRAW);
                        gl.vertexAttribPointer(aPositionPointer, 4, gl.FLOAT, false, 0, 0);
                        gl.enableVertexAttribArray(aPositionPointer);

                        // Bind the texture for this face
                        gl.activeTexture(gl.TEXTURE0);
                        gl.bindTexture(gl.TEXTURE_2D, loadedTextures[d8FaceTextures[i]]);
                        gl.uniform1i(gl.getUniformLocation(program, "uSampler"), 0);

                        // Draw the face
                        gl.drawArrays(gl.TRIANGLES, 0, 3); // Each face is 3 vertices
                    }
                }

                function drawD12() {
                    gl.uniform1i(gl.getUniformLocation(program, "uUseTexture"), false);

                    // Draw solid D12 base
                    gl.bindBuffer(gl.ARRAY_BUFFER, diceTwelveBuffer);
                    gl.vertexAttribPointer(aPositionPointer, 3, gl.FLOAT, false, 0, 0);

                    gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, diceTwelveIndicesBuffer);
                    gl.uniform4f(colorLocation, 0.3, 0.3, 0.7, 1.0);
                    gl.drawElements(gl.TRIANGLES, diceTwelveIndices.length, gl.UNSIGNED_BYTE, 0);

                    // Draw D12 edges
                    gl.uniform4f(colorLocation, 1.0, 1.0, 1.0, 1.0);
                    gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, diceTwelveEdgesBuffer);
                    gl.drawElements(gl.LINES, diceTwelveEdges.length, gl.UNSIGNED_BYTE, 0);

                    // --- Draw Textured D12 Faces ---
                    gl.uniform1i(gl.getUniformLocation(program, "uUseTexture"), true);

                    // Bind the UV coordinates for pentagonal faces
                    gl.bindBuffer(gl.ARRAY_BUFFER, d12FaceUVBuffer);
                    gl.vertexAttribPointer(aTexCoordPointer, 2, gl.FLOAT, false, 0, 0);
                    gl.enableVertexAttribArray(aTexCoordPointer);

                    for (let i = 0; i < 12; i++) {
                        // Update buffer with this face's vertices
                        gl.bindBuffer(gl.ARRAY_BUFFER, d12TexturedFacePosBuffer);
                        gl.bufferData(gl.ARRAY_BUFFER, d12TexturedFaces[i], gl.DYNAMIC_DRAW);
                        gl.vertexAttribPointer(aPositionPointer, 4, gl.FLOAT, false, 0, 0);
                        gl.enableVertexAttribArray(aPositionPointer);

                        // Bind the texture for this face
                        gl.activeTexture(gl.TEXTURE0);
                        gl.bindTexture(gl.TEXTURE_2D, loadedTextures[`d12_${i + 1}`]);
                        gl.uniform1i(gl.getUniformLocation(program, "uSampler"), 0);

                        // Draw the face as a triangle fan (pentagon)
                        gl.drawArrays(gl.TRIANGLE_FAN, 0, 5);
                    }
                }

            }

            // function changeDice(dice) {
            //     currentDice = dice;
            // }

            function addDice(type) {
                if (diceList.length >= MAX_DICE) {
                    alert(`Maximum of ${MAX_DICE} dice allowed!`);
                    return;
                }

                // Random position above the floor
                const index = diceList.length;
                const totalPositions = MAX_DICE;
                const angle = (index / totalPositions) * Math.PI*2;
                const radius = 0.5; // distance from center
                const x = Math.cos(angle) * radius;
                const y = FLOOR_Y + 1.5; // Start above the floor
                const z = Math.sin(angle) * radius;

                let angularDamping = 0.3;
                let linearDamping = 0.1;

                // Create a physics body based on dice type
                let shape, size;
                switch(type) {
                    case "diceFour":
                        // Create a modified tetrahedron with slightly flattened vertices to improve stability
                        const d4Vertices = [
                            new CANNON.Vec3(0.25, 0.25, 0.25),    // V0
                            new CANNON.Vec3(-0.25, -0.25, 0.25),  // V1
                            new CANNON.Vec3(-0.25, 0.25, -0.25),  // V2
                            new CANNON.Vec3(0.25, -0.25, -0.25)   // V3
                        ];
                        
                        // Add tiny offset to lower center of mass slightly (makes it more stable)
                        for (let i = 0; i < d4Vertices.length; i++) {
                            d4Vertices[i].y -= 0.02; // Slight downward shift of all vertices
                        }
                        
                        const d4Faces = [
                            [0, 1, 2], // Face 1
                            [0, 1, 3], // Face 2
                            [0, 2, 3], // Face 3
                            [1, 2, 3]  // Face 4
                        ];
                        
                        shape = new CANNON.ConvexPolyhedron(d4Vertices, d4Faces);
                        
                        // Higher angular damping specifically for D4
                        angularDamping = 0.7;  // Much higher than default
                        linearDamping = 0.3;   // Higher than default
                        
                        size = 0.25;
                        break;
                    case "diceSix":
                        // Perfect match for a box shape
                        shape = new CANNON.Box(new CANNON.Vec3(0.25, 0.25, 0.25));
                        size = 0.25;
                        break;
                    case "diceEight":
                        // Create an octahedral shape
                        const d8Vertices = [
                            new CANNON.Vec3(0, 0, 0.5),   // Top vertex
                            new CANNON.Vec3(0, 0, -0.5),  // Bottom vertex
                            new CANNON.Vec3(0.5, 0, 0),   // Right vertex
                            new CANNON.Vec3(-0.5, 0, 0),  // Left vertex
                            new CANNON.Vec3(0, 0.5, 0),   // Front vertex
                            new CANNON.Vec3(0, -0.5, 0)   // Back vertex
                        ];
                        
                        // Define the 8 triangular faces
                        const d8Faces = [
                            [0, 2, 4], // Top-Right-Front
                            [0, 4, 3], // Top-Front-Left
                            [0, 3, 5], // Top-Left-Back
                            [0, 5, 2], // Top-Back-Right
                            [1, 2, 4], // Bottom-Right-Front
                            [1, 4, 3], // Bottom-Front-Left
                            [1, 3, 5], // Bottom-Left-Back
                            [1, 5, 2]  // Bottom-Back-Right
                        ];
                        
                        shape = new CANNON.ConvexPolyhedron(d8Vertices, d8Faces);
                        size = 0.35; // Maintain the larger size
                        break;
                    case "diceTwelve":
                        const t = (1 + Math.sqrt(5)) / 2;
                        const r = 1 / t;
                        const scale = 0.25;
                        
                        // Create d12 vertices
                        const d12Vertices = [
                            new CANNON.Vec3(-scale, -scale, -scale),
                            new CANNON.Vec3(-scale, -scale, scale),
                            new CANNON.Vec3(-scale, scale, -scale),
                            new CANNON.Vec3(-scale, scale, scale),
                            new CANNON.Vec3(scale, -scale, -scale),
                            new CANNON.Vec3(scale, -scale, scale),
                            new CANNON.Vec3(scale, scale, -scale),
                            new CANNON.Vec3(scale, scale, scale),
                            new CANNON.Vec3(0, -r*scale, -t*scale),
                            new CANNON.Vec3(0, -r*scale, t*scale),
                            new CANNON.Vec3(0, r*scale, -t*scale),
                            new CANNON.Vec3(0, r*scale, t*scale),
                            new CANNON.Vec3(-r*scale, -t*scale, 0),
                            new CANNON.Vec3(-r*scale, t*scale, 0),
                            new CANNON.Vec3(r*scale, -t*scale, 0),
                            new CANNON.Vec3(r*scale, t*scale, 0),
                            new CANNON.Vec3(-t*scale, 0, -r*scale),
                            new CANNON.Vec3(t*scale, 0, -r*scale),
                            new CANNON.Vec3(-t*scale, 0, r*scale),
                            new CANNON.Vec3(t*scale, 0, r*scale)
                        ];
                        
                        // Manually defined faces with correct winding order
                        const d12Faces = [
                            [0, 16, 2, 10, 8],   // Fixed winding order for face 1
                            [0, 8, 4, 14, 12],   // Fixed winding order for face 2
                            [0, 12, 1, 18, 16],  // Fixed winding order for face 3
                            [1, 12, 14, 5, 9],   // Fixed winding order for face 4
                            [1, 9, 11, 3, 18],   // Fixed winding order for face 5
                            [2, 16, 18, 3, 13],  // Fixed winding order for face 6
                            [2, 13, 15, 6, 10],  // Fixed winding order for face 7
                            [3, 11, 7, 15, 13],  // Fixed winding order for face 8
                            [4, 8, 10, 6, 17],   // Fixed winding order for face 9
                            [4, 17, 19, 5, 14],  // Fixed winding order for face 10
                            [5, 19, 7, 11, 9],   // Fixed winding order for face 11
                            [6, 15, 7, 19, 17]   // Fixed winding order for face 12
                        ];
                        
                        // Force convex shape creation with proper normals
                        shape = new CANNON.ConvexPolyhedron(d12Vertices, d12Faces);
                        
                        // Make sure we consistently compute edges, faces and normals
                        shape.computeEdges();
                        shape.computeNormals();
                        shape.updateBoundingSphereRadius();
                        
                        size = 0.3;
                        break;
                }

                // Create the physics body
                const body = new CANNON.Body({
                    mass: 0.0, // 1kg
                    material: diceMaterial,
                    shape: shape,
                    position: new CANNON.Vec3(x, y, z),
                    quaternion: new CANNON.Quaternion(0,0,0,1),
                    // Use custom damping values if defined
                    angularDamping: angularDamping || 0.3,
                    linearDamping: linearDamping || 0.1,
                    allowSleep: true,
                    sleepSpeedLimit: 0.05,
                    sleepTimeLimit: 1.0,
                    // EXTRA SETTINGS FOR D4:
                    fixedRotation: type === "diceFour" ? true : false,  // Only during floating state
                });

                // Random initial velocity and angular velocity
                //body.velocity.set(
                //    (Math.random() - 0.5) * 3,  // Random X velocity
                //    -1 - Math.random() * 2,     // Downward Y velocity
                //    (Math.random() - 0.5) * 3   // Random Z velocity
                //);
                //body.angularVelocity.set(
                //    (Math.random() - 0.5) * 5,  // Random rotation
                //    (Math.random() - 0.5) * 5,
                //    (Math.random() - 0.5) * 5
                //);

                // No initial velocity
                body.velocity.set(0, 0, 0);
                body.angularVelocity.set(0, 0, 0);
                
                // Add body to physics world
                world.addBody(body);

                const diceIndex = diceList.length;
                diceList.push({
                    type: type,
                    index: diceList.length,
                    body: body,
                    size: size,
                    floating: true,
                    rotationAxis: [
                        Math.random() - 0.5,
                        Math.random() - 0.5,
                        Math.random() - 0.5
                    ],
                    hasCollided: false, // new property to track first collision
                });

                // add collision event listener
                body.addEventListener("collide", function(event){
                    const dice = diceList.find(d => d.body.id == body.id);
                    if (dice && !dice.hasCollided){
                        // first collision detected
                        dice.hasCollided = true;
                        playRandomDiceSound();
                    }
                })    
            }

            function createSafeConvexPolyhedron(vertices, faces) {
                // Create convex polyhedron with auto-calculated normals
                const shape = new CANNON.ConvexPolyhedron(vertices, faces);
                
                // Force recalculation of normals
                for (let i = 0; i < shape.faces.length; i++) {
                    const face = shape.faces[i];
                    const verts = face.map(idx => shape.vertices[idx]);
                    
                    // Calculate face normal
                    const normal = new CANNON.Vec3();
                    for (let j = 0; j < verts.length; j++) {
                        const v1 = verts[j];
                        const v2 = verts[(j+1) % verts.length];
                        normal.x += (v1.y - v2.y) * (v1.z + v2.z);
                        normal.y += (v1.z - v2.z) * (v1.x + v2.x);
                        normal.z += (v1.x - v2.x) * (v1.y + v2.y);
                    }
                    normal.normalize();
                    
                    // Make sure normal points outward
                    const centroid = new CANNON.Vec3();
                    for (let j = 0; j < verts.length; j++) {
                        centroid.vadd(verts[j], centroid);
                    }
                    centroid.scale(1/verts.length, centroid);
                    
                    if (centroid.dot(normal) < 0) {
                        normal.scale(-1, normal);
                    }
                    
                    shape.faceNormals[i] = normal;
                }
                
                return shape;
            }

            function removeDice() {
                if (diceList.length > 0) {
                    const dice = diceList.pop();
                    if (dice.body){
                        world.removeBody(dice.body);
                    }
                }
            }

            function rollDice() {
                needsValueUpdate = true;
                lastRollTime = Date.now();
                
                for (let i = 0; i < diceList.length; i++) {
                    const dice = diceList[i]; // This was the correct part
                    if (!dice.body) continue;

                    // For any dice that are sleeping, wake them up
                    if (dice.body.sleepState === CANNON.Body.SLEEPING) {
                        dice.body.wakeUp();
                    }

                    // Temporarily disable sleeping to ensure the dice move freely during initial roll
                    dice.body.allowSleep = false;
                    
                    // Reset value calculation flag
                    dice.valueCalculated = false;
                    
                    // Change to active physics
                    if (dice.floating) {
                        // reset collision flag when rolling the dice
                        dice.hasCollided = false;

                        // Change mass to make it affected by gravity
                        dice.floating = false;
                        
                        // Create a completely new body with the same properties but with mass
                        const oldBody = dice.body;
                        const newBody = new CANNON.Body({
                            mass: dice.type === "diceFour" ? 0.8 : 0.5, // Higher mass for D4
                            material: diceMaterial,
                            shape: oldBody.shapes[0],
                            position: new CANNON.Vec3().copy(oldBody.position),
                            quaternion: new CANNON.Quaternion().copy(oldBody.quaternion),
                            angularDamping: dice.type === "diceFour" ? 0.7 : 0.3,
                            linearDamping: dice.type === "diceFour" ? 0.3 : 0.1,
                            allowSleep: false,
                            sleepSpeedLimit: 0.05,
                            sleepTimeLimit: 1.0
                        });

                        newBody.addEventListener("collide", function(event){
                            if(!dice.hasCollided){
                                dice.hasCollided = true;
                                playRandomDiceSound();
                            }
                        })
                        
                        // Remove old body and add new one
                        world.removeBody(oldBody);
                        world.addBody(newBody);
                        dice.body = newBody;

                        // Calculate backward force direction (away from center)
                        const pos = newBody.position;
                        const distFromCenter = Math.sqrt(pos.x/2);

                        // normalize the direction vector
                        let dirX = 0;
                        let dirZ = 0;

                        if (distFromCenter > 0.001) {
                            // Direction pointing outward from center
                            dirX = pos.x / distFromCenter;
                            dirZ = pos.z / distFromCenter;
                        } else {
                            // If very close to center, use a random direction
                            const randomAngle = Math.random() * Math.PI * 2;
                            dirX = Math.cos(randomAngle);
                            dirZ = Math.sin(randomAngle);
                        }

                        // Apply backward force
                        const backwardForce = 5.0;
                                    
                        // Add a bit more initial energy to make it move
                        dice.body.velocity.set(
                            dirX * backwardForce,
                            1.0,
                            dirZ * backwardForce
                        );
                        
                        // Add some random spin
                        dice.body.angularVelocity.set(
                            (Math.random() - 0.5) * 8,
                            (Math.random() - 0.5) * 8,
                            (Math.random() - 0.5) * 8
                        );
                    } else {
                        // For dice that are already active, just add some new energy
                        dice.body.velocity.set(
                            (Math.random() - 0.5) * 3.0,
                            8.5,
                            (Math.random() - 0.5) * 3.0
                        );
                        
                        dice.body.angularVelocity.set(
                            (Math.random() - 0.5) * 10,
                            (Math.random() - 0.5) * 10,
                            (Math.random() - 0.5) * 10
                        );

                        // sound plays after sometime when re-tossed from the ground
                        setTimeout(() => {
                            dice.hasCollided = false;
                        }, 200);
                    }
                }
                // Schedule re-enabling of sleep after dice have had time to start moving
                setTimeout(enableDiceSleep, 500);
            }

            function enableDiceSleep() {
                for (let i = 0; i < diceList.length; i++) {
                    const dice = diceList[i];
                    if (dice.body) {
                        // Re-enable sleeping
                        dice.body.allowSleep = true;
                    }
                }
            }

            function forceSleepIfNeeded() {
                // Don't apply this to dice that were just rolled
                if (Date.now() - lastRollTime < 2000) return;
                
                for (let i = 0; i < diceList.length; i++) {
                    const dice = diceList[i];
                    if (!dice.body || dice.body.sleepState === CANNON.Body.SLEEPING) continue;
                    
                    const linVelMagnitude = dice.body.velocity.lengthSquared();
                    const angVelMagnitude = dice.body.angularVelocity.lengthSquared();
                    
                    // Special case for D4 - more aggressive sleep forcing
                    if (dice.type === "diceFour") {
                        // D4 needs stricter sleep conditions
                        if (linVelMagnitude < 0.005 && angVelMagnitude < 0.005) {
                            dice.body.sleep();
                            
                            // Once sleeping, check if the D4 is balancing on a vertex
                            // If so, apply a small impulse to make it fall onto a face
                            const pos = dice.body.position;
                            if (pos.y > FLOOR_Y + 0.15) { // If suspiciously high off the floor
                                // Apply a small random impulse to tip it over
                                const randomAngle = Math.random() * Math.PI * 2;
                                dice.body.applyImpulse(
                                    new CANNON.Vec3(
                                        Math.cos(randomAngle) * 0.01,
                                        0,
                                        Math.sin(randomAngle) * 0.01
                                    ),
                                    new CANNON.Vec3(pos.x, pos.y, pos.z)
                                );
                                dice.body.wakeUp();
                            }
                        }
                    } else {
                        // Normal dice - use standard sleep checks
                        if (linVelMagnitude < 0.001 && angVelMagnitude < 0.001) {
                            const now = Date.now();
                            if (!dice.stableStart) {
                                dice.stableStart = now;
                            } else if (now - dice.stableStart > 500) {
                                dice.body.sleep();
                            }
                        } else {
                            dice.stableStart = null;
                        }
                    }
                }
            }

            document.getElementById("diceFourBtn").addEventListener("click", () => addDice("diceFour"));
            document.getElementById("diceSixBtn").addEventListener("click", () => addDice("diceSix"));
            document.getElementById("diceEightBtn").addEventListener("click", () => addDice("diceEight"));
            document.getElementById("diceTwelveBtn").addEventListener("click", () => addDice("diceTwelve"));
            document.getElementById("removeDiceBtn").addEventListener("click", removeDice);
            document.getElementById("rollDiceBtn").addEventListener('click', rollDice);
            document.addEventListener("keydown", function(event){
                // check is space bar is pressed (key code == 32)
                if (event.code === "Space" || event.keyCode === 32){
                    event.preventDefault();

                    //roll the mothaflippin dice
                    rollDice();
                }
            })

            // drawScene(); // Removed: Initial draw is now handled by onTextureLoaded
            // animate();   // Removed: Animation starts after textures load
        }

    </script>
</head>

<body onload="main()">
    <canvas id="main_canvas" width="1500" height="700" style="border: 1px black solid;"></canvas>
    <div class="buttons">
        <div class="buttonsFirstRow">
            <button class="diceBtn" id="diceFourBtn">D4</button>
            <button class="diceBtn" id="diceSixBtn">D6</button>
            <button class="diceBtn" id="diceEightBtn">D8</button>
            <button class="diceBtn" id="diceTwelveBtn">D12</button>
            <button class="diceBtn" id="removeDiceBtn">Remove</button>
        </div>
        <button class="diceBtn" id="rollDiceBtn">Roll</button>
        <h1 style="color: white; font-size: large">or press the 'Spacebar'!</h1>
    </div>
    <div id="diceValues" style="position: absolute; bottom: 20px; left: 50%; transform: translateX(-50%); background-color: rgba(0,0,0,0.7); color: white; padding: 10px 20px; border-radius: 5px; font-size: 18px; font-family: Arial, sans-serif; text-align: center;"></div>
</body>

</html>