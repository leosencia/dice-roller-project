<!DOCTYPE html>
<html>
    <head>
        <title>Dice Roller</title>
        <style>
            body { 
                margin: 0; 
                padding: 0; 
                overflow: hidden; 
            }
            canvas { 
                width: 100vw; 
                height: 100vh; 
                display: block; 
            }
            .buttons{
                position: absolute;
                top: 10px;
                left: 10px;
                z-index: 1;
                width: 100%;
                display: flex;
                flex-direction: row;
                justify-content: center;   
                gap: 5px;
            }
            .diceBtn{
                width: 70px;
            }
        </style>
        <!--Vertex Shader-->
        <script type="x-shader/x-vertex" id="vshader">
            attribute vec4 aPosition;
            attribute vec2 aTexCoord;
            
            uniform mat4 uModelMatrix;
            uniform mat4 uViewMatrix;
            uniform mat4 uProjectionMatrix;
            
            varying vec2 vTexCoord;

            void main() {
                gl_Position = uProjectionMatrix * uViewMatrix * uModelMatrix * aPosition;
                vTexCoord = aTexCoord;
            }
        </script>

        <!--Fragment Shader-->
        <script type="x-shader/x-fragment" id="fshader">
            precision mediump float;

            uniform vec4 u_color;
            varying vec2 vTexCoord;
            uniform sampler2D uSampler;

            uniform bool uUseTexture;

            void main(void) {
                if (uUseTexture) {
                    gl_FragColor = texture2D(uSampler, vTexCoord);
                } else {
                    gl_FragColor = u_color;
                }
            }
        </script>

        <!--Import external javascript file-->
        <!--Helper javascript methods for initializing webgl-->
        <script src="./lib/webgl-init.js"></script>
        <script src="./lib/webgl-utils.js"></script>
        <script src="./lib/webgl-debug.js"></script>
        <script src="./lib/gl-matrix-min.js"></script>

        <script>
            function main() {
                // Retrieve <canvas> element
                var canvas = document.getElementById("main_canvas");
                if (!canvas) {
                    console.log("Failed to retrieve the <canvas> element");
                }
                
                // Cylindrical environment parameters
                const CYLINDER_RADIUS = 2.0;   // Radius of the cylinder and floor
                const CYLINDER_HEIGHT = 8.0;   // Conceptual height of the invisible cylinder
                const FLOOR_Y = -0.5;         // Y-position of the floor
                const MAX_DICE = 2;           // Maximum number of dice allowed

                // Dice management
                let diceList = []; 

                // Rendering Context
                var gl = initializeWebGL(canvas,true);
                // Initialize Shaders Program
                var vertexShader = initializeShader(gl, "vshader");
                var fragmentShader = initializeShader(gl, "fshader");
                var program = initializeProgram(gl, vertexShader, fragmentShader);
                gl.useProgram(program);

                var aPositionPointer = gl.getAttribLocation(program, "aPosition");
                var aTexCoordPointer = gl.getAttribLocation(program, "aTexCoord")
                gl.enableVertexAttribArray(aPositionPointer);
                gl.enableVertexAttribArray(aTexCoordPointer);

                var colorLocation = gl.getUniformLocation(program, "u_color");

                
                var uModelMatrixPointer = gl.getUniformLocation(program, "uModelMatrix");
                var uViewMatrixPointer = gl.getUniformLocation(program, "uViewMatrix");
                var uProjectionMatrixPointer = gl.getUniformLocation(program, "uProjectionMatrix");

                // Camera position parameters (editable)
                let eyeX = 2.0; // Original: 1.0
                let eyeY = 4.0; // Original: 2.0
                let eyeZ = 6.0; // Original: 3.0

                var modelMatrix;
                var viewMatrix;
                var projectionMatrix;

                // Projection Matrix Specification
                var fieldOfViewYAxis = glMatrix.toRadian(30);
                var aspectRatio      = canvas.width/canvas.height;
                var nearPlane        = 1;
                var farPlane         = 100;

                // Create floor disk (only visible part of the cylindrical environment)
                function createFloorDisk(numSegments = 64) {
                    const verts = [];
                    const texCoords = []; // UVs for consistency, though floor will be solid color
                    
                    // Center vertex for TRIANGLE_FAN
                    verts.push(0, FLOOR_Y, 0, 1.0);
                    texCoords.push(0.5, 0.5);
                    
                    // Perimeter vertices
                    for (let i = 0; i <= numSegments; ++i) {
                        const theta = (i / numSegments) * 2 * Math.PI;
                        verts.push(
                            CYLINDER_RADIUS * Math.cos(theta),
                            FLOOR_Y,
                            CYLINDER_RADIUS * Math.sin(theta),
                            1.0
                        );
                        texCoords.push(
                            0.5 + 0.5 * Math.cos(theta), // Simple planar UV mapping
                            0.5 + 0.5 * Math.sin(theta)
                        );
                    }
                    return { 
                        vertices: new Float32Array(verts), 
                        uvCoords: new Float32Array(texCoords),
                        vertexCount: numSegments + 2 // Center + perimeter vertices
                    };
                }
                
                // Generate floor disk geometry and buffers
                const floorDisk = createFloorDisk();
                
                const floorPositionBuffer = gl.createBuffer();
                gl.bindBuffer(gl.ARRAY_BUFFER, floorPositionBuffer);
                gl.bufferData(gl.ARRAY_BUFFER, floorDisk.vertices, gl.STATIC_DRAW);
                
                const floorTexCoordBuffer = gl.createBuffer();
                gl.bindBuffer(gl.ARRAY_BUFFER, floorTexCoordBuffer);
                gl.bufferData(gl.ARRAY_BUFFER, floorDisk.uvCoords, gl.STATIC_DRAW);

                // Function to check if a position is outside the cylindrical boundary (for future physics)
                // Assumes objectCenter is an array [x, y, z] and objectRadius is its bounding radius
                function isOutsideCylinder(objectCenter, objectRadius = 0.25) { // Default radius, adjust as needed
                    const [x, y, z] = objectCenter;
                    
                    // Check floor/ceiling boundaries
                    const tooLow = y - objectRadius < FLOOR_Y;
                    const tooHigh = y + objectRadius > (FLOOR_Y + CYLINDER_HEIGHT); // Conceptual ceiling
                    
                    // Check radial boundary (distance from central Y-axis in XZ plane)
                    const distanceFromCenterXZ = Math.hypot(x, z);
                    const tooFar = distanceFromCenterXZ + objectRadius > CYLINDER_RADIUS;
                    
                    return tooLow || tooHigh || tooFar;
                }

                projectionMatrix = mat4.create();
                mat4.perspective(projectionMatrix,fieldOfViewYAxis,aspectRatio,nearPlane,farPlane);
                gl.uniformMatrix4fv(uProjectionMatrixPointer,false,new Float32Array(projectionMatrix));

                // View Matrix Specification
                var lookAtPoint = [0.0,0.0,0.0,1.0];              //where the camera is looking
                var eyePoint    = [eyeX, eyeY, eyeZ, 1.0];        //where the camera is placed
                var upVector    = [0.0,1.0,0.0,0.0];              //orientation of the camera

                viewMatrix = mat4.create();
                mat4.lookAt(viewMatrix,eyePoint,lookAtPoint,upVector);
                gl.uniformMatrix4fv(uViewMatrixPointer,false,new Float32Array(viewMatrix));

                // Model Matrix
                modelMatrix = mat4.create();
                modelMatrix = mat4.identity(modelMatrix);
                gl.uniformMatrix4fv(uModelMatrixPointer,false,new Float32Array(modelMatrix));

                //D4 Dice
                var diceFour = [
                    0.25, 0.25, 0.25, 1.0,  // V0
                    -0.25, -0.25, 0.25, 1.0, // V1
                    -0.25, 0.25, -0.25, 1.0, // V2
                    0.25, -0.25, -0.25, 1.0  // V3
                ];

                // D4 Face UVs (standard for a triangle)
                const d4FaceUVs = [
                    0.5, 1.0, // Top/center vertex of texture
                    0.0, 0.0, // Bottom-left vertex of texture
                    1.0, 0.0  // Bottom-right vertex of texture
                ];
                const d4FaceUVBuffer = gl.createBuffer();
                gl.bindBuffer(gl.ARRAY_BUFFER, d4FaceUVBuffer);
                gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(d4FaceUVs), gl.STATIC_DRAW);

                // Helper to create D4 face geometry (vertices offset along normal)
                function createD4TexturedFace(vIndices, allVertices, S, offsetAmount) {
                    const v = [
                        vec3.fromValues(allVertices[vIndices[0]*4], allVertices[vIndices[0]*4+1], allVertices[vIndices[0]*4+2]),
                        vec3.fromValues(allVertices[vIndices[1]*4], allVertices[vIndices[1]*4+1], allVertices[vIndices[1]*4+2]),
                        vec3.fromValues(allVertices[vIndices[2]*4], allVertices[vIndices[2]*4+1], allVertices[vIndices[2]*4+2])
                    ];

                    const edge1 = vec3.subtract([], v[1], v[0]);
                    const edge2 = vec3.subtract([], v[2], v[0]);
                    const normal = vec3.cross([], edge1, edge2);
                    vec3.normalize(normal, normal);

                    // Ensure normal points outwards (heuristic: dot product with position vector of centroid)
                    const centroid = vec3.scale([],vec3.add([],vec3.add([],v[0],v[1]),v[2]),1/3);
                    if (vec3.dot(normal, centroid) < 0) {
                        vec3.scale(normal, normal, -1);
                    }
                    
                    const offsetVec = vec3.scale([], normal, offsetAmount);

                    const faceVerts = [];
                    for (let i = 0; i < 3; i++) {
                        const v_offset = vec3.add([], v[i], offsetVec);
                        faceVerts.push(v_offset[0], v_offset[1], v_offset[2], 1.0);
                    }
                    return new Float32Array(faceVerts);
                }

                const d4FaceOffset = 0.01; // How much to offset textured faces

                // Define D4 faces based on indices (V0,V1,V2), (V0,V1,V3), (V0,V2,V3), (V1,V2,V3)
                // These will be associated with textures d4_1, d4_2, d4_3, d4_4 respectively
                const d4Face1Verts = createD4TexturedFace([0, 1, 2], diceFour, 0.25, d4FaceOffset);
                const d4Face2Verts = createD4TexturedFace([0, 1, 3], diceFour, 0.25, d4FaceOffset);
                const d4Face3Verts = createD4TexturedFace([0, 2, 3], diceFour, 0.25, d4FaceOffset);
                const d4Face4Verts = createD4TexturedFace([1, 2, 3], diceFour, 0.25, d4FaceOffset);
                
                // Buffer for D4 face positions (will be updated for each face)
                const d4TexturedFacePosBuffer = gl.createBuffer();

                // D8 face vertex offsets (the faces will be slightly offset to avoid z-fighting)
                const d8FaceOffset = 0.01;
                
                // Helper to create D8 face geometry from indices
                function createD8TexturedFace(indices, allVertices, offsetAmount) {
                    // Extract the vertices for this face using the indices into the diceEight array
                    const v = [
                        vec3.fromValues(allVertices[indices[0]*4], allVertices[indices[0]*4+1], allVertices[indices[0]*4+2]),
                        vec3.fromValues(allVertices[indices[1]*4], allVertices[indices[1]*4+1], allVertices[indices[1]*4+2]),
                        vec3.fromValues(allVertices[indices[2]*4], allVertices[indices[2]*4+1], allVertices[indices[2]*4+2])
                    ];

                    // Calculate face normal vector
                    const edge1 = vec3.subtract([], v[1], v[0]);
                    const edge2 = vec3.subtract([], v[2], v[0]);
                    const normal = vec3.cross([], edge1, edge2);
                    vec3.normalize(normal, normal);

                    // Check direction and flip if needed to ensure normal points outward
                    const centroid = vec3.scale([], vec3.add([], vec3.add([], v[0], v[1]), v[2]), 1/3);
                    if (vec3.dot(normal, centroid) < 0) {
                        vec3.scale(normal, normal, -1);
                    }
                    
                    // Offset vertices along normal
                    const offsetVec = vec3.scale([], normal, offsetAmount);
                    const faceVerts = [];
                    for (let i = 0; i < 3; i++) {
                        const v_offset = vec3.add([], v[i], offsetVec);
                        faceVerts.push(v_offset[0], v_offset[1], v_offset[2], 1.0);
                    }
                    
                    return new Float32Array(faceVerts);
                }
                
                // Buffer for D8 face positions (will be updated for each face)
                const d8TexturedFacePosBuffer = gl.createBuffer();

                const d12FaceOffset = 0.01; // How much to offset D12 textured faces

                // D12 pentagon UV coordinates - maps the texture to a pentagon
                const d12FaceUVs = [
                    0.5, 1.0,  // Top vertex
                    0.0, 0.65, // Upper left
                    0.0, 0.15, // Lower left
                    1.0, 0.15, // Lower right
                    1.0, 0.65  // Upper right
                ];
                const d12FaceUVBuffer = gl.createBuffer();
                gl.bindBuffer(gl.ARRAY_BUFFER, d12FaceUVBuffer);
                gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(d12FaceUVs), gl.STATIC_DRAW);

                // Helper to create D12 face geometry (vertices slightly offset along normal)
                function createD12TexturedFace(indices, allVertices, offsetAmount) {
                    // Extract vertices for the pentagon face (each face is 5 vertices)
                    const v = [];
                    for (let i = 0; i < 5; i++) {
                        v.push(vec3.fromValues(
                            allVertices[indices[i]*3], 
                            allVertices[indices[i]*3+1], 
                            allVertices[indices[i]*3+2]
                        ));
                    }

                    // Calculate face normal by taking cross product of two edges
                    const edge1 = vec3.subtract([], v[1], v[0]);
                    const edge2 = vec3.subtract([], v[2], v[0]);
                    const normal = vec3.cross([], edge1, edge2);
                    vec3.normalize(normal, normal);

                    // Calculate centroid to ensure normal points outward
                    const centroid = [0, 0, 0];
                    for (let i = 0; i < 5; i++) {
                        centroid[0] += v[i][0];
                        centroid[1] += v[i][1];
                        centroid[2] += v[i][2];
                    }
                    centroid[0] /= 5;
                    centroid[1] /= 5;
                    centroid[2] /= 5;

                    if (vec3.dot(normal, centroid) < 0) {
                        vec3.scale(normal, normal, -1); // Ensure normal points outward
                    }

                    // Offset vertices along normal
                    const offsetVec = vec3.scale([], normal, offsetAmount);
                    const faceVerts = [];
                    for (let i = 0; i < 5; i++) {
                        const v_offset = vec3.add([], v[i], offsetVec);
                        faceVerts.push(v_offset[0], v_offset[1], v_offset[2], 1.0);
                    }

                    return new Float32Array(faceVerts);
                }

                // Buffer for D12 face positions
                const d12TexturedFacePosBuffer = gl.createBuffer();

                // D6 Dice
                var diceSix = [
                    // Front face
                    -0.25, -0.25,  0.25, 1.0,
                    0.25, -0.25,  0.25, 1.0,
                    0.25,  0.25,  0.25, 1.0,
                    -0.25,  0.25,  0.25, 1.0,
                    // Back face
                    -0.25, -0.25, -0.25, 1.0,
                    -0.25,  0.25, -0.25, 1.0,
                    0.25,  0.25, -0.25, 1.0,
                    0.25, -0.25, -0.25, 1.0,
                    // Top face
                    -0.25,  0.25, -0.25, 1.0,
                    -0.25,  0.25,  0.25, 1.0,
                    0.25,  0.25,  0.25, 1.0,
                    0.25,  0.25, -0.25, 1.0,
                    // Bottom face
                    -0.25, -0.25, -0.25, 1.0,
                    0.25, -0.25, -0.25, 1.0,
                    0.25, -0.25,  0.25, 1.0,
                    -0.25, -0.25,  0.25, 1.0,
                    // Right face
                    0.25, -0.25, -0.25, 1.0,
                    0.25,  0.25, -0.25, 1.0,
                    0.25,  0.25,  0.25, 1.0,
                    0.25, -0.25,  0.25, 1.0,
                    // Left face
                    -0.25, -0.25, -0.25, 1.0,
                    -0.25, -0.25,  0.25, 1.0,
                    -0.25,  0.25,  0.25, 1.0,
                    -0.25,  0.25, -0.25, 1.0
                ];

                // D8 Dice
                var diceEight = [
                    0.0, 0.0, 0.5, 1.0,   // Top vertex (doubled from 0.25)
                    0.0, 0.0, -0.5, 1.0,  // Bottom vertex (doubled from 0.25)
                    0.5, 0.0, 0.0, 1.0,   // Right vertex (doubled from 0.25)
                    -0.5, 0.0, 0.0, 1.0,  // Left vertex (doubled from 0.25)
                    0.0, 0.5, 0.0, 1.0,   // Front vertex (doubled from 0.25)
                    0.0, -0.5, 0.0, 1.0   // Back vertex (doubled from 0.25)
                ];

                // D12 Dice
                // Reference: https://github.com/mrdoob/three.js/blob/master/src/geometries/DodecahedronGeometry.js
                const t = (1 + Math.sqrt(5)) / 2;
                const r = 1 / t;
                var diceTwelve = [
                    // (±1, ±1, ±1)
                    - 1, - 1, - 1,	- 1, - 1, 1,
                    - 1, 1, - 1, - 1, 1, 1,
                    1, - 1, - 1, 1, - 1, 1,
                    1, 1, - 1, 1, 1, 1,

                    // (0, ±1/φ, ±φ)
                    0, - r, - t, 0, - r, t,
                    0, r, - t, 0, r, t,

                    // (±1/φ, ±φ, 0)
                    - r, - t, 0, - r, t, 0,
                    r, - t, 0, r, t, 0,

                    // (±φ, 0, ±1/φ)
                    - t, 0, - r, t, 0, - r,
                    - t, 0, r, t, 0, r
                ]

                // Scale factor to see the shape better
                var rad = 0.25;
                    for (let i = 0; i < diceTwelve.length; i++) {
                    diceTwelve[i] *= rad;
                }

                // Buffer Creation
                gl.enableVertexAttribArray(aPositionPointer);

                var diceFourBuffer = gl.createBuffer();
                gl.bindBuffer(gl.ARRAY_BUFFER, diceFourBuffer);
                gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(diceFour), gl.STATIC_DRAW);
                gl.vertexAttribPointer(aPositionPointer, 4, gl.FLOAT, false, 0, 0);
                
                var diceSixBuffer = gl.createBuffer();
                gl.bindBuffer(gl.ARRAY_BUFFER, diceSixBuffer);
                gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(diceSix), gl.STATIC_DRAW);
                gl.vertexAttribPointer(aPositionPointer, 4, gl.FLOAT, false, 0, 0);

                var diceEightBuffer = gl.createBuffer();
                gl.bindBuffer(gl.ARRAY_BUFFER, diceEightBuffer);
                gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(diceEight), gl.STATIC_DRAW);
                gl.vertexAttribPointer(aPositionPointer, 4, gl.FLOAT, false, 0, 0);

                var diceTwelveBuffer = gl.createBuffer();
                gl.bindBuffer(gl.ARRAY_BUFFER, diceTwelveBuffer);
                gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(diceTwelve), gl.STATIC_DRAW);
                gl.vertexAttribPointer(aPositionPointer, 3, gl.FLOAT, false, 0, 0);
                


                // Index Array for D4
                var diceFourIndices = [
                    0, 1, 2,
                    0, 1, 3,
                    0, 2, 3,
                    1, 2, 3
                ];

                // Index Array for D6
                var diceSixIndices = [
                    0, 1, 2,      0, 2, 3,    // Front face
                    4, 5, 6,      4, 6, 7,    // Back face
                    8, 9, 10,     8, 10, 11,  // Top face
                    12, 13, 14,   12, 14, 15, // Bottom face
                    16, 17, 18,   16, 18, 19, // Right face
                    20, 21, 22,   20, 22, 23  // Left face
                ];

                // Index Array for D8
                var diceEightIndices = [
                    0, 2, 4,   // Top Side
                    0, 4, 3,
                    0, 3, 5,
                    0, 5, 2,
                    1, 2, 4,   // Bottom Side
                    1, 3, 4,
                    1, 3, 5,
                    1, 2, 5
                ];

                // Index Array for D12
                var diceTwelveIndices = [
                    3, 11, 7, 	3, 7, 15, 	3, 15, 13,
                    7, 19, 17, 	7, 17, 6, 	7, 6, 15,
                    17, 4, 8, 	17, 8, 10, 	17, 10, 6,
                    8, 0, 16, 	8, 16, 2, 	8, 2, 10,
                    0, 12, 1, 	0, 1, 18, 	0, 18, 16,
                    6, 10, 2, 	6, 2, 13, 	6, 13, 15,
                    2, 16, 18, 	2, 18, 3, 	2, 3, 13,
                    18, 1, 9, 	18, 9, 11, 	18, 11, 3,
                    4, 14, 12, 	4, 12, 0, 	4, 0, 8,
                    11, 9, 5, 	11, 5, 19, 	11, 19, 7,
                    19, 5, 14, 	19, 14, 4, 	19, 4, 17,
                    1, 12, 14, 	1, 14, 5, 	1, 5, 9
                ]

                // D8 Number Texture
                var diceSixUVFace = [
                    0.0, 1.0,
                    1.0, 1.0,
                    0.0, 0.0,
                    1.0, 0.0,
                ]

                // Edge Outlines
                // D4 Edge Outlines
                var diceFourEdges = [
                    0, 1,
                    0, 2,
                    0, 3,
                    1, 2,
                    1, 3,
                    2, 3
                ]

                var diceFourEdgesBuffer = gl.createBuffer();
                gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, diceFourEdgesBuffer);
                gl.bufferData(gl.ELEMENT_ARRAY_BUFFER, new Uint8Array(diceFourEdges), gl.STATIC_DRAW);
                gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, null);

                // D6 Edge Outlines
                var diceSixEdges = [
                    0, 1,
                    1, 2,
                    2, 3,
                    3, 0,

                    // Back face
                    4, 5,
                    5, 6,
                    6, 7,
                    7, 4,

                    // Top face
                    8, 9,
                    9,10,
                    10,11,
                    11,8,

                    // Bottom face
                    12,13,
                    13,14,
                    14,15,
                    15,12,

                    // Right face
                    16,17,
                    17,18,
                    18,19,
                    19,16,

                    // Left face
                    20,21,
                    21,22,
                    22,23,
                    23,20
                ];

                var diceSixEdgesBuffer = gl.createBuffer();
                gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, diceSixEdgesBuffer);
                gl.bufferData(gl.ELEMENT_ARRAY_BUFFER, new Uint8Array(diceSixEdges), gl.STATIC_DRAW);
                gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, null);

                // D8 Edge Outlines
                var diceEightEdges = [
                    // Top
                    0, 2,
                    0, 4,
                    0, 3,
                    0, 5,
                    
                    // Side or Center
                    2, 4,
                    3, 4,
                    3, 5,
                    2, 5,

                    // Bottom
                    1, 2,
                    1, 4,
                    1, 3,
                    1, 5
                ];

                var diceEightEdgesBuffer = gl.createBuffer();
                gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, diceEightEdgesBuffer);
                gl.bufferData(gl.ELEMENT_ARRAY_BUFFER, new Uint8Array(diceEightEdges), gl.STATIC_DRAW);
                gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, null);

                // Create D8 textured face vertices now that diceEightIndices is defined
                const d8TexturedFaces = [];
                for (let i = 0; i < 8; i++) {
                    // Each face in diceEightIndices is defined by 3 indices that are consecutive
                    const faceIndices = [
                        diceEightIndices[i*3], 
                        diceEightIndices[i*3+1], 
                        diceEightIndices[i*3+2]
                    ];
                    d8TexturedFaces.push(createD8TexturedFace(faceIndices, diceEight, d8FaceOffset));
                }

                var diceTwelveEdges = [];
                for (let i = 0; i < diceTwelveIndices.length; i += 9) {
                    const indices = [
                        diceTwelveIndices[i], diceTwelveIndices[i+1], diceTwelveIndices[i+2],
                        diceTwelveIndices[i+3], diceTwelveIndices[i+4], diceTwelveIndices[i+5],
                        diceTwelveIndices[i+6], diceTwelveIndices[i+7], diceTwelveIndices[i+8],
                    ];

                    // Get unique indices (removing duplicates)
                    const uniqueIndices = [...new Set(indices)];

                    // Add line segments between consecutive points and wrap around
                    for (let j = 0; j < 5; j++) {
                        const a = uniqueIndices[j];
                        const b = uniqueIndices[(j + 1) % 5];
                        diceTwelveEdges.push(a, b);  // store as line segment
                    }
                }

                var diceTwelveEdgesBuffer = gl.createBuffer();
                gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, diceTwelveEdgesBuffer);
                gl.bufferData(gl.ELEMENT_ARRAY_BUFFER, new Uint8Array(diceTwelveEdges), gl.STATIC_DRAW);
                gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, null);

                // Create D12 textured faces now that diceTwelveIndices is defined
                const d12TexturedFaces = [];
                // A D12 has 12 pentagonal faces, each defined by 5 unique vertices
                // We need to extract these from the diceTwelveIndices
                for (let i = 0; i < diceTwelveIndices.length; i += 9) {
                    // Each 9 indices defines one face in three triangles
                    const triangleIndices = [
                        diceTwelveIndices[i], diceTwelveIndices[i+1], diceTwelveIndices[i+2],
                        diceTwelveIndices[i+3], diceTwelveIndices[i+4], diceTwelveIndices[i+5],
                        diceTwelveIndices[i+6], diceTwelveIndices[i+7], diceTwelveIndices[i+8]
                    ];
                    
                    // Extract the unique vertices (5 for a pentagon)
                    const uniqueIndices = [...new Set(triangleIndices)];
                    
                    // Create the textured face with these unique vertices
                    d12TexturedFaces.push(createD12TexturedFace(uniqueIndices, diceTwelve, d12FaceOffset));
                }

                var diceFourIndicesBuffer = gl.createBuffer();
                gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, diceFourIndicesBuffer);
                gl.bufferData(gl.ELEMENT_ARRAY_BUFFER, new Uint8Array(diceFourIndices), gl.STATIC_DRAW);
                gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, null);

                var diceSixIndicesBuffer = gl.createBuffer();
                gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, diceSixIndicesBuffer);
                gl.bufferData(gl.ELEMENT_ARRAY_BUFFER, new Uint8Array(diceSixIndices), gl.STATIC_DRAW);
                gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, null);

                var diceEightIndicesBuffer = gl.createBuffer();
                gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, diceEightIndicesBuffer);
                gl.bufferData(gl.ELEMENT_ARRAY_BUFFER, new Uint8Array(diceEightIndices), gl.STATIC_DRAW);
                gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, null);

                var diceTwelveIndicesBuffer = gl.createBuffer();
                gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, diceTwelveIndicesBuffer);
                gl.bufferData(gl.ELEMENT_ARRAY_BUFFER, new Uint8Array(diceTwelveIndices), gl.STATIC_DRAW);
                gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, null);

                gl.clearColor(0.5,0.5,0.5,1.0);
                gl.clear(gl.COLOR_BUFFER_BIT);
                gl.enable(gl.DEPTH_TEST);
                
                let currentDice = "diceFour";

                // Texture Loader
                function textureLoader(gl, source, onLoadCallback) {
                    const texture = gl.createTexture();
                    const image = new Image();
                    image.crossOrigin = "anonymous";
                    image.src = source;

                    image.onload = function () {
                        gl.bindTexture(gl.TEXTURE_2D, texture);
                        gl.pixelStorei(gl.UNPACK_FLIP_Y_WEBGL, true);
                        gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, gl.RGBA, gl.UNSIGNED_BYTE, image);
                        gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE);
                        gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE);
                        gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.LINEAR);

                        onLoadCallback(texture); // Call back with the loaded texture
                    };

                    return texture;
                }

                let loadedTextures = {};
                let texturesLoaded = 0;
                const TOTAL_TEXTURES_TO_LOAD = 18; // 6 for D6, 4 for D4, 8 for D8

                function onTextureLoaded(name, tex) {
                    loadedTextures[name] = tex;
                    texturesLoaded++;

                    if (texturesLoaded === TOTAL_TEXTURES_TO_LOAD) { // Check if all textures are loaded
                        drawScene(); // Initial draw after all textures are ready
                        animate(); // Start animation loop
                    }
                }

                // D6 Textures
                textureLoader(gl, "images/d6/1.png", (tex) => onTextureLoaded("front", tex));
                textureLoader(gl, "images/d6/6.png", (tex) => onTextureLoaded("back", tex));
                textureLoader(gl, "images/d6/2.png", (tex) => onTextureLoaded("top", tex));
                textureLoader(gl, "images/d6/5.png", (tex) => onTextureLoaded("bottom", tex));
                textureLoader(gl, "images/d6/3.png", (tex) => onTextureLoaded("right", tex));
                textureLoader(gl, "images/d6/4.png", (tex) => onTextureLoaded("left", tex));

                // D4 Textures
                textureLoader(gl, "images/d4/1.png", (tex) => onTextureLoaded("d4_1", tex));
                textureLoader(gl, "images/d4/2.png", (tex) => onTextureLoaded("d4_2", tex));
                textureLoader(gl, "images/d4/3.png", (tex) => onTextureLoaded("d4_3", tex));
                textureLoader(gl, "images/d4/4.png", (tex) => onTextureLoaded("d4_4", tex));

                // D8 Textures
                textureLoader(gl, "images/d8/1.png", (tex) => onTextureLoaded("d8_1", tex));
                textureLoader(gl, "images/d8/2.png", (tex) => onTextureLoaded("d8_2", tex));
                textureLoader(gl, "images/d8/3.png", (tex) => onTextureLoaded("d8_3", tex));
                textureLoader(gl, "images/d8/4.png", (tex) => onTextureLoaded("d8_4", tex));
                textureLoader(gl, "images/d8/5.png", (tex) => onTextureLoaded("d8_5", tex));
                textureLoader(gl, "images/d8/6.png", (tex) => onTextureLoaded("d8_6", tex));
                textureLoader(gl, "images/d8/7.png", (tex) => onTextureLoaded("d8_7", tex));
                textureLoader(gl, "images/d8/8.png", (tex) => onTextureLoaded("d8_8", tex));

                //D12 Textures
                textureLoader(gl, "images/d12/1.png", (tex) => onTextureLoaded("d12_1", tex));
                textureLoader(gl, "images/d12/2.png", (tex) => onTextureLoaded("d12_2", tex));
                textureLoader(gl, "images/d12/3.png", (tex) => onTextureLoaded("d12_3", tex));
                textureLoader(gl, "images/d12/4.png", (tex) => onTextureLoaded("d12_4", tex));
                textureLoader(gl, "images/d12/5.png", (tex) => onTextureLoaded("d12_5", tex));
                textureLoader(gl, "images/d12/6.png", (tex) => onTextureLoaded("d12_6", tex));
                textureLoader(gl, "images/d12/7.png", (tex) => onTextureLoaded("d12_7", tex));
                textureLoader(gl, "images/d12/8.png", (tex) => onTextureLoaded("d12_8", tex));
                textureLoader(gl, "images/d12/9.png", (tex) => onTextureLoaded("d12_9", tex));
                textureLoader(gl, "images/d12/10.png", (tex) => onTextureLoaded("d12_10", tex));
                textureLoader(gl, "images/d12/11.png", (tex) => onTextureLoaded("d12_11", tex));
                textureLoader(gl, "images/d12/12.png", (tex) => onTextureLoaded("d12_12", tex));

                // For preventing the textures in being rendered in different dice
                function createBlankTexture(gl) {
                    const texture = gl.createTexture();
                    gl.bindTexture(gl.TEXTURE_2D, texture);

                    const blankPixel = new Uint8Array([0, 0, 0, 0]); // Transparent
                    gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, 1, 1, 0, gl.RGBA, gl.UNSIGNED_BYTE, blankPixel);

                    return texture;
                }

                const blankTexture = createBlankTexture(gl);

                var diceSixFaceFront = [
                    -0.25,  0.25,  0.26, 1.0,
                    0.25,  0.25,  0.26, 1.0,
                    -0.25, -0.25,  0.26, 1.0,
                    0.25, -0.25,  0.26, 1.0
                ];

                var diceSixFaceBack = [
                    0.25,  0.25, -0.26, 1.0,
                    -0.25,  0.25, -0.26, 1.0,
                    0.25, -0.25, -0.26, 1.0,
                    -0.25, -0.25, -0.26, 1.0
                ]

                var diceSixFaceTop = [
                    -0.25,  0.26,  0.25, 1.0,
                    -0.25,  0.26, -0.25, 1.0,
                    0.25,  0.26,  0.25, 1.0,
                    0.25,  0.26, -0.25, 1.0
                ]

                var diceSixFaceBottom = [
                    -0.25, -0.26,  0.25, 1.0,
                    0.25, -0.26,  0.25, 1.0,
                    -0.25, -0.26, -0.25, 1.0,
                    0.25, -0.26, -0.25, 1.0,
                ]

                var diceSixFaceRight = [
                    0.26, -0.25,  0.25, 1.0,
                    0.26,  0.25,  0.25, 1.0,
                    0.26, -0.25, -0.25, 1.0,
                    0.26,  0.25, -0.25, 1.0,
                ]

                var diceSixFaceLeft = [
                    -0.26,  0.25,  0.25, 1.0,
                    -0.26, -0.25,  0.25, 1.0,
                    -0.26,  0.25, -0.25, 1.0,
                    -0.26, -0.25, -0.25, 1.0,
                ]
                

                // Initial Rendering (of D4)
                // This initial draw call before animate() might not be needed if onTextureLoaded handles the first draw.
                // gl.bindBuffer(gl.ARRAY_BUFFER, diceFourBuffer);
                // gl.vertexAttribPointer(aPositionPointer, 4, gl.FLOAT, false, 0, 0);
                // gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, diceFourIndicesBuffer);
                // gl.uniform4f(colorLocation,0.7,0.3,0.3,1.0);
                // gl.drawElements(gl.TRIANGLES, diceFourIndices.length, gl.UNSIGNED_BYTE, 0);
                
                // For Rotation
                let rotationSpeed = 0.005;
                let isRotating = true;

                // Get the value of the D4 Dice
                // ONLY CALL THIS AFTER THE ROLL
                function getTopD4Value(modelMatrix) {
                    const diceFourPerVer = [
                        [ 0.25,  0.25,  0.25, 1.0],  // V0
                        [-0.25, -0.25,  0.25, 1.0],  // V1
                        [-0.25,  0.25, -0.25, 1.0],  // V2
                        [ 0.25, -0.25, -0.25, 1.0]   // V3
                    ];

                    let maxY = -Infinity;
                    let topVertexIndex = -1;

                    for (let i = 0; i < diceFourPerVer.length; i++) {
                        const v = diceFourPerVer[i];
                        const vertex = vec4.fromValues(v[0], v[1], v[2], v[3]);
                        const transformed = vec4.create();
                        vec4.transformMat4(transformed, vertex, modelMatrix);

                        if (transformed[1] > maxY) {
                            maxY = transformed[1];
                            topVertexIndex = i;
                        }
                    }

                    const valueMap = [1, 3, 4, 2];
                    return valueMap[topVertexIndex];
                }


                // Get the value of the D6 Dice
                // ONLY CALL THIS AFTER THE ROLL
                function getTopD6Value () {
                    const faceCenters = {
                        front:  [ 0.0,  0.0,  0.25, 1.0],
                        back:   [ 0.0,  0.0, -0.25, 1.0],
                        top:    [ 0.0,  0.25,  0.0,  1.0],
                        bottom: [ 0.0, -0.25,  0.0,  1.0],
                        right:  [ 0.25, 0.0,  0.0,  1.0],
                        left:   [-0.25, 0.0,  0.0,  1.0]
                    };

                    // Map face names to die values based on texture mapping
                    const faceToValue = {
                        top: 2,
                        bottom: 5,
                        front: 1,
                        back: 6,
                        right: 3,
                        left: 4
                    };

                    let topFace = null;
                    let maxY = -Infinity;

                    for (const [face, center] of Object.entries(faceCenters)) {
                        const transformed = vec4.create();
                        const original = vec4.fromValues(...center);
                        vec4.transformMat4(transformed, original, modelMatrix);

                        if (transformed[1] > maxY) {
                            maxY = transformed[1];
                            topFace = face;
                        }
                    }

                    return faceToValue[topFace];
                }

                // Get the value of the D8 Dice
                // ONLY CALL THIS AFTER THE ROLL
                function getTopD8Value(modelMatrix) {
                    let maxY = -Infinity;
                    let topFaceIndex = -1;

                    // Each face is 3 indices, so loop in steps of 3
                    for (let i = 0; i < diceEightIndices.length; i += 3) {
                        const idx0 = diceEightIndices[i] * 4;
                        const idx1 = diceEightIndices[i + 1] * 4;
                        const idx2 = diceEightIndices[i + 2] * 4;

                        const v0 = vec4.fromValues(
                            diceEight[idx0], diceEight[idx0 + 1], diceEight[idx0 + 2], diceEight[idx0 + 3]
                        );
                        const v1 = vec4.fromValues(
                            diceEight[idx1], diceEight[idx1 + 1], diceEight[idx1 + 2], diceEight[idx1 + 3]
                        );
                        const v2 = vec4.fromValues(
                            diceEight[idx2], diceEight[idx2 + 1], diceEight[idx2 + 2], diceEight[idx2 + 3]
                        );

                        // Average the three vertices to get the center point of the face
                        const center = vec4.fromValues(
                            (v0[0] + v1[0] + v2[0]) / 3,
                            (v0[1] + v1[1] + v2[1]) / 3,
                            (v0[2] + v1[2] + v2[2]) / 3,
                            1.0
                        );

                        // Transform the center using modelMatrix
                        const transformedCenter = vec4.create();
                        vec4.transformMat4(transformedCenter, center, modelMatrix);

                        if (transformedCenter[1] > maxY) {
                            maxY = transformedCenter[1];
                            topFaceIndex = i / 3;
                        }
                    }

                    const valueMap = [1, 2, 3, 4, 5, 6, 7, 8];
                    const topValue = valueMap[topFaceIndex];

                    return topValue;
                }


                 // Get the value of the D12 Dice
                // ONLY CALL THIS AFTER THE ROLL
                function getTopD12Value(modelMatrix) {
                    let maxY = -Infinity;
                    let topFaceIndex = -1;

                    // D12 vertex positions use 3 components per vertex
                    const numTriangles = diceTwelveIndices.length / 3;

                    for (let i = 0; i < diceTwelveIndices.length; i += 3) {
                        const idx0 = diceTwelveIndices[i] * 3;
                        const idx1 = diceTwelveIndices[i + 1] * 3;
                        const idx2 = diceTwelveIndices[i + 2] * 3;

                        const v0 = vec4.fromValues(
                            diceTwelve[idx0], diceTwelve[idx0 + 1], diceTwelve[idx0 + 2], 1.0
                        );
                        const v1 = vec4.fromValues(
                            diceTwelve[idx1], diceTwelve[idx1 + 1], diceTwelve[idx1 + 2], 1.0
                        );
                        const v2 = vec4.fromValues(
                            diceTwelve[idx2], diceTwelve[idx2 + 1], diceTwelve[idx2 + 2], 1.0
                        );

                        // Compute face center
                        const center = vec4.fromValues(
                            (v0[0] + v1[0] + v2[0]) / 3,
                            (v0[1] + v1[1] + v2[1]) / 3,
                            (v0[2] + v1[2] + v2[2]) / 3,
                            1.0
                        );

                        // Transform the center using model matrix
                        const transformedCenter = vec4.create();
                        vec4.transformMat4(transformedCenter, center, modelMatrix);

                        // Track highest Y
                        if (transformedCenter[1] > maxY) {
                            maxY = transformedCenter[1];
                            topFaceIndex = Math.floor(i / 9); // 9 indices = 3 triangles per pentagon
                        }
                    }

                    const faceValues = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12];
                    return faceValues[topFaceIndex];
                }


                function animate() {

                    if (isRotating) {
                    mat4.rotate(modelMatrix, modelMatrix, rotationSpeed, [1, 0, 0]);
                    gl.uniformMatrix4fv(uModelMatrixPointer, false, modelMatrix);

                    mat4.rotate(modelMatrix, modelMatrix, rotationSpeed, [0, 0, 1]);
                    gl.uniformMatrix4fv(uModelMatrixPointer, false, modelMatrix);
                    }

                    drawScene();
                    requestAnimationFrame(animate);
                }


                function drawScene() {
                    gl.clearColor(0,0,0,1.0);
                    gl.clear(gl.COLOR_BUFFER_BIT | gl.DEPTH_BUFFER_BIT); // Added DEPTH_BUFFER_BIT

                    // --- Draw the Floor Disk ---
                    gl.uniform1i(gl.getUniformLocation(program, "uUseTexture"), false); // Tell shader not to use texture
                    
                    // Set model matrix for the floor (identity, so it doesn't move/rotate with dice)
                    const floorModelMatrix = mat4.create(); // Identity matrix
                    gl.uniformMatrix4fv(uModelMatrixPointer, false, floorModelMatrix);
                    
                    // Bind floor vertex data
                    gl.bindBuffer(gl.ARRAY_BUFFER, floorPositionBuffer);
                    gl.vertexAttribPointer(aPositionPointer, 4, gl.FLOAT, false, 0, 0);
                    gl.enableVertexAttribArray(aPositionPointer);
                    
                    // Bind floor UV data (even if not used, good practice to have it bound if attrib is enabled elsewhere)
                    gl.bindBuffer(gl.ARRAY_BUFFER, floorTexCoordBuffer);
                    gl.vertexAttribPointer(aTexCoordPointer, 2, gl.FLOAT, false, 0, 0);
                    gl.enableVertexAttribArray(aTexCoordPointer); // Keep it enabled

                    // Set floor color to white
                    gl.uniform4f(colorLocation, 0.2,0.711,0.945, 1.0); 
                    
                    // Draw the floor
                    gl.drawArrays(gl.TRIANGLE_FAN, 0, floorDisk.vertexCount);

                    // --- Restore Dice Model Matrix and Draw Dice ---
                    gl.uniformMatrix4fv(uModelMatrixPointer, false, modelMatrix); // Restore original modelMatrix for dice

                    // Draw all dice in the diceList
                    for(let i=0; i<diceList.length; i++){
                        const dice = diceList[i];
                        
                        // calculate position for the die
                        //**spread dice on the floor
                        const angle = (i/diceList.length)*Math.PI*2;
                        const radius = 0.5;
                        const x = Math.cos(angle) * radius;
                        const z = Math.sin(angle) * radius;
                        
                        // create model matrix for the die
                        const diceModelMatrix = mat4.create();
                        mat4.translate(diceModelMatrix, diceModelMatrix, [x, 0, z]);
                        mat4.multiply(diceModelMatrix, diceModelMatrix, modelMatrix);
                        gl.uniformMatrix4fv(uModelMatrixPointer, false, diceModelMatrix);

                        if (dice.type === "diceFour") drawD4();
                        else if (dice.type === "diceSix") drawD6();
                        else if (dice.type === "diceEight") drawD8();
                        else if (dice.type === "diceTwelve") drawD12();
                      
                    }
                    
                    //draw part
                    function drawD4() {
                        gl.uniform1i(gl.getUniformLocation(program, "uUseTexture"), false);
                        
                        // Draw solid D4 base
                        gl.bindBuffer(gl.ARRAY_BUFFER, diceFourBuffer);
                        gl.vertexAttribPointer(aPositionPointer, 4, gl.FLOAT, false, 0, 0);
                        gl.enableVertexAttribArray(aPositionPointer); // Ensure it's enabled

                        gl.uniform4f(colorLocation,0.7,0.3,0.3,1.0); // D4 base color
                        gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, diceFourIndicesBuffer);
                        gl.drawElements(gl.TRIANGLES, diceFourIndices.length, gl.UNSIGNED_BYTE, 0);

                        // Draw D4 edges
                        gl.uniform4f(colorLocation,1.0,1.0,1.0,1.0); // Edge color
                        gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, diceFourEdgesBuffer);
                        gl.drawElements(gl.LINES, diceFourEdges.length, gl.UNSIGNED_BYTE, 0);

                        // --- Draw Textured D4 Faces ---
                        gl.uniform1i(gl.getUniformLocation(program, "uUseTexture"), true);
                        
                        gl.bindBuffer(gl.ARRAY_BUFFER, d4FaceUVBuffer); // Use common UV buffer for all D4 faces
                        gl.vertexAttribPointer(aTexCoordPointer, 2, gl.FLOAT, false, 0, 0);
                        gl.enableVertexAttribArray(aTexCoordPointer);

                        const facesVerts = [d4Face1Verts, d4Face2Verts, d4Face3Verts, d4Face4Verts];
                        const faceTextures = ["d4_1", "d4_2", "d4_3", "d4_4"];

                        for (let i = 0; i < 4; i++) {
                            gl.bindBuffer(gl.ARRAY_BUFFER, d4TexturedFacePosBuffer);
                            gl.bufferData(gl.ARRAY_BUFFER, facesVerts[i], gl.DYNAMIC_DRAW); // Update buffer data
                            gl.vertexAttribPointer(aPositionPointer, 4, gl.FLOAT, false, 0, 0);
                            // aPositionPointer should still be enabled from drawing the base

                            gl.activeTexture(gl.TEXTURE0);
                            gl.bindTexture(gl.TEXTURE_2D, loadedTextures[faceTextures[i]]);
                            gl.uniform1i(gl.getUniformLocation(program, "uSampler"), 0);
                            
                            gl.drawArrays(gl.TRIANGLES, 0, 3); // Each face is 3 vertices
                        }
                        
                    } 
                    
                    function drawD6() {
                        gl.uniform1i(gl.getUniformLocation(program, "uUseTexture"), false);

                        gl.bindBuffer(gl.ARRAY_BUFFER, diceSixBuffer);
                        gl.vertexAttribPointer(aPositionPointer, 4, gl.FLOAT, false, 0, 0);

                        gl.uniform4f(colorLocation,0.0,0.0,0.0,1.0);
                        gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, diceSixIndicesBuffer);
                        gl.drawElements(gl.TRIANGLES, diceSixIndices.length, gl.UNSIGNED_BYTE, 0);

                        gl.uniform4f(colorLocation,1.0,1.0,1.0,1.0);
                        gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, diceSixEdgesBuffer);
                        gl.drawElements(gl.LINES, diceSixEdges.length, gl.UNSIGNED_BYTE, 0);
                        
                        // Rendering Texture ==================================================================
                        // === FRONT FACE ===
                        gl.uniform1i(gl.getUniformLocation(program, "uUseTexture"), true);

                        // === Setup Buffers ===
                        const positionBuffer = gl.createBuffer();
                        const uvBuffer = gl.createBuffer();

                        gl.bindBuffer(gl.ARRAY_BUFFER, uvBuffer);
                        gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(diceSixUVFace), gl.STATIC_DRAW);
                        gl.enableVertexAttribArray(aTexCoordPointer);
                        gl.vertexAttribPointer(aTexCoordPointer, 2, gl.FLOAT, false, 0, 0);
                            
                        gl.bindBuffer(gl.ARRAY_BUFFER, positionBuffer);
                        gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(diceSixFaceFront), gl.STATIC_DRAW);
                        gl.enableVertexAttribArray(aPositionPointer);
                        gl.vertexAttribPointer(aPositionPointer, 4, gl.FLOAT, false, 0, 0);

                        gl.activeTexture(gl.TEXTURE0);
                        gl.bindTexture(gl.TEXTURE_2D, loadedTextures["front"]);
                        gl.uniform1i(gl.getUniformLocation(program, "uSampler"), 0);

                        gl.drawArrays(gl.TRIANGLE_STRIP, 0, 4);

                        // === BACK FACE ===
                        gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(diceSixFaceBack), gl.STATIC_DRAW);

                        gl.activeTexture(gl.TEXTURE0);
                        gl.bindTexture(gl.TEXTURE_2D, loadedTextures["back"]);
                        gl.uniform1i(gl.getUniformLocation(program, "uSampler"), 0);

                        gl.drawArrays(gl.TRIANGLE_STRIP, 0, 4);

                        // === TOP FACE ===
                        gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(diceSixFaceTop), gl.STATIC_DRAW);

                        gl.activeTexture(gl.TEXTURE0);
                        gl.bindTexture(gl.TEXTURE_2D, loadedTextures["top"]);
                        gl.uniform1i(gl.getUniformLocation(program, "uSampler"), 0);

                        gl.drawArrays(gl.TRIANGLE_STRIP, 0, 4);

                        // === BOTTOM FACE ===
                        gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(diceSixFaceBottom), gl.STATIC_DRAW);

                        gl.activeTexture(gl.TEXTURE0);
                        gl.bindTexture(gl.TEXTURE_2D, loadedTextures["bottom"]);
                        gl.uniform1i(gl.getUniformLocation(program, "uSampler"), 0);
                        
                        gl.drawArrays(gl.TRIANGLE_STRIP, 0, 4);

                        // === RIGHT FACE ===
                        gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(diceSixFaceRight), gl.STATIC_DRAW);

                        gl.activeTexture(gl.TEXTURE0);
                        gl.bindTexture(gl.TEXTURE_2D, loadedTextures["right"]);
                        gl.uniform1i(gl.getUniformLocation(program, "uSampler"), 0);
                        
                        gl.drawArrays(gl.TRIANGLE_STRIP, 0, 4);

                        // === LEFT FACE ===
                        gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(diceSixFaceLeft), gl.STATIC_DRAW);

                        gl.activeTexture(gl.TEXTURE0);
                        gl.bindTexture(gl.TEXTURE_2D, loadedTextures["left"]);
                        gl.uniform1i(gl.getUniformLocation(program, "uSampler"), 0);
                        
                        gl.drawArrays(gl.TRIANGLE_STRIP, 0, 4);
                        
                    }
                    
                    function drawD8() {
                        gl.uniform1i(gl.getUniformLocation(program, "uUseTexture"), false);

                        // Draw solid D8 base
                        gl.bindBuffer(gl.ARRAY_BUFFER, diceEightBuffer);
                        gl.vertexAttribPointer(aPositionPointer, 4, gl.FLOAT, false, 0, 0);

                        gl.uniform4f(colorLocation,0.3,0.3,0.7,1.0);
                        gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, diceEightIndicesBuffer);
                        gl.drawElements(gl.TRIANGLES, diceEightIndices.length, gl.UNSIGNED_BYTE, 0);

                        // Draw D8 edges
                        gl.uniform4f(colorLocation,1.0,1.0,1.0,1.0);
                        gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, diceEightEdgesBuffer);
                        gl.drawElements(gl.LINES, diceEightEdges.length, gl.UNSIGNED_BYTE, 0);

                        // --- Draw Textured D8 Faces ---
                        gl.uniform1i(gl.getUniformLocation(program, "uUseTexture"), true);
                        
                        gl.bindBuffer(gl.ARRAY_BUFFER, d4FaceUVBuffer); // Reuse the D4 UV buffer as they're both triangular faces
                        gl.vertexAttribPointer(aTexCoordPointer, 2, gl.FLOAT, false, 0, 0);
                        gl.enableVertexAttribArray(aTexCoordPointer);

                        const d8FaceTextures = [
                            "d8_1", "d8_2", "d8_3", "d8_4", "d8_5", "d8_6", "d8_7", "d8_8"
                        ];

                        for (let i = 0; i < 8; i++) {
                            // Update buffer with this face's vertices
                            gl.bindBuffer(gl.ARRAY_BUFFER, d8TexturedFacePosBuffer);
                            gl.bufferData(gl.ARRAY_BUFFER, d8TexturedFaces[i], gl.DYNAMIC_DRAW);
                            gl.vertexAttribPointer(aPositionPointer, 4, gl.FLOAT, false, 0, 0);
                            gl.enableVertexAttribArray(aPositionPointer);

                            // Bind the texture for this face
                            gl.activeTexture(gl.TEXTURE0);
                            gl.bindTexture(gl.TEXTURE_2D, loadedTextures[d8FaceTextures[i]]);
                            gl.uniform1i(gl.getUniformLocation(program, "uSampler"), 0);
                            
                            // Draw the face
                            gl.drawArrays(gl.TRIANGLES, 0, 3); // Each face is 3 vertices
                        }
                    }
                    
                    function drawD12() {
                        gl.uniform1i(gl.getUniformLocation(program, "uUseTexture"), false);
                    
                        // Draw solid D12 base
                        gl.bindBuffer(gl.ARRAY_BUFFER, diceTwelveBuffer);
                        gl.vertexAttribPointer(aPositionPointer, 3, gl.FLOAT, false, 0, 0);
                    
                        gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, diceTwelveIndicesBuffer);
                        gl.uniform4f(colorLocation, 0.3, 0.3, 0.7, 1.0);
                        gl.drawElements(gl.TRIANGLES, diceTwelveIndices.length, gl.UNSIGNED_BYTE, 0);
                    
                        // Draw D12 edges
                        gl.uniform4f(colorLocation, 1.0, 1.0, 1.0, 1.0);
                        gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, diceTwelveEdgesBuffer);
                        gl.drawElements(gl.LINES, diceTwelveEdges.length, gl.UNSIGNED_BYTE, 0);
                        
                        // --- Draw Textured D12 Faces ---
                        gl.uniform1i(gl.getUniformLocation(program, "uUseTexture"), true);
                        
                        // Bind the UV coordinates for pentagonal faces
                        gl.bindBuffer(gl.ARRAY_BUFFER, d12FaceUVBuffer);
                        gl.vertexAttribPointer(aTexCoordPointer, 2, gl.FLOAT, false, 0, 0);
                        gl.enableVertexAttribArray(aTexCoordPointer);
                        
                        for (let i = 0; i < 12; i++) {
                            // Update buffer with this face's vertices
                            gl.bindBuffer(gl.ARRAY_BUFFER, d12TexturedFacePosBuffer);
                            gl.bufferData(gl.ARRAY_BUFFER, d12TexturedFaces[i], gl.DYNAMIC_DRAW);
                            gl.vertexAttribPointer(aPositionPointer, 4, gl.FLOAT, false, 0, 0);
                            gl.enableVertexAttribArray(aPositionPointer);
                            
                            // Bind the texture for this face
                            gl.activeTexture(gl.TEXTURE0);
                            gl.bindTexture(gl.TEXTURE_2D, loadedTextures[`d12_${i+1}`]);
                            gl.uniform1i(gl.getUniformLocation(program, "uSampler"), 0);
                            
                            // Draw the face as a triangle fan (pentagon)
                            gl.drawArrays(gl.TRIANGLE_FAN, 0, 5);
                        }
                    }

                }
                                        
                // function changeDice(dice) {
                //     currentDice = dice;
                // }

                function addDice(type){
                    if(diceList.length >= MAX_DICE){
                        alert(`Maximum of ${MAX_DICE} dice allowed!`);
                        return;
                    }
                    
                    diceList.push({
                        type: type,
                        index: diceList.length
                    });
                }

                function removeDice(){
                    if(diceList.length > 0){
                        diceList.pop();
                    }
                }

                document.getElementById("diceFourBtn").addEventListener("click", () => addDice("diceFour"));
                document.getElementById("diceSixBtn").addEventListener("click", () => addDice("diceSix"));
                document.getElementById("diceEightBtn").addEventListener("click", () => addDice("diceEight"));
                document.getElementById("diceTwelveBtn").addEventListener("click", () => addDice("diceTwelve"));
                document.getElementById("removeDiceBtn").addEventListener("click", removeDice);

                // drawScene(); // Removed: Initial draw is now handled by onTextureLoaded
                // animate();   // Removed: Animation starts after textures load
            }
            
        </script>
    </head>

    <body onload="main()">
        <canvas id="main_canvas" width="1500" height="700" style="border: 1px black solid;"></canvas>
        <div class="buttons">
            <button class="diceBtn" id="diceFourBtn">D4</button>
            <button class="diceBtn" id="diceSixBtn">D6</button>
            <button class="diceBtn" id="diceEightBtn">D8</button>
            <button class="diceBtn" id="diceTwelveBtn" >D12</button>
            <button class="diceBtn" id="removeDiceBtn">Remove</button>
        </div>
    </body>
</html>